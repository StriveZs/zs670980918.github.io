<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>嵩嵩❤婷婷</title>
  
  <subtitle>StriveZs的Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.strivezs.com/"/>
  <updated>2022-08-23T06:37:56.074Z</updated>
  <id>www.strivezs.com/</id>
  
  <author>
    <name>StriveZs</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MVSNet depthfusion配置流程</title>
    <link href="www.strivezs.com/2022/08/23/MVSNet%20depthfusion%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B/"/>
    <id>www.strivezs.com/2022/08/23/MVSNet%20depthfusion%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B/</id>
    <published>2022-08-23T06:37:56.074Z</published>
    <updated>2022-08-23T06:37:56.074Z</updated>
    
    <content type="html"><![CDATA[<h1>MVSNet depthfusion配置流程</h1><h2 id="原文内容"><a class="header-anchor" href="#原文内容">¶</a>原文内容</h2><p>R/MVSNet itself only produces per-view depth maps. To generate the 3D point cloud, we need to apply depth map filter/fusion for post-processing. As our implementation of this part is depended on the Altizure internal library, currently we could not provide the corresponding code.<br>Fortunately, depth map filter/fusion is a general step in MVS reconstruction, and there are similar implementations in other open-source MVS algorithms. We provide the script <a href="http://depthfusion.py">depthfusion.py</a> to utilize fusibile for post-processing (thank Silvano Galliani for the excellent code!).</p><p>To run the post-processing:</p><ul><li>Check out the modified version fusibile git clone <a href="https://github.com/YoYo000/fusibile">https://github.com/YoYo000/fusibile</a></li><li>Install fusibile by cmake . and make, which will generate the executable at FUSIBILE_EXE_PATH</li><li>Run post-processing (–prob_threshold 0.8 if using 3DCNNs): python <a href="http://depthfusion.py">depthfusion.py</a> --dense_folder TEST_DATA_FOLDER --fusibile_exe_path FUSIBILE_EXE_PATH --prob_threshold 0.3</li><li>The final point cloud is stored in TEST_DATA_FOLDER/points_mvsnet/consistencyCheck-TIME/final3d_model.ply.</li></ul><p>使用Origin Fusible代码融合出来的点云颜色是没有的，这里YaoYao通过修改了代码使得Gipuma融合出来的点云是由颜色的, 下面是YaoYao给出的代码: <a href="https://github.com/YoYo000/fusibile">click here</a></p><h2 id="CMakeList配置需求"><a class="header-anchor" href="#CMakeList配置需求">¶</a>CMakeList配置需求</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required (VERSION 3.9)</span><br><span class="line">project (fusibile)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable C++11 globally</span></span><br><span class="line"><span class="builtin-name">set</span>(CMAKE_CXX_STANDARD 11)</span><br><span class="line"><span class="builtin-name">set</span>(CMAKE_CXX_STANDARD_REQUIRED ON)</span><br><span class="line"><span class="builtin-name">set</span>(CMAKE_CXX_EXTENSIONS OFF)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Support IDEs: https://cliutils.gitlab.io/modern-cmake/chapters/features/ides.html</span></span><br><span class="line">set_property(GLOBAL PROPERTY USE_FOLDERS ON)</span><br><span class="line">set_property(GLOBAL PROPERTY PREDEFINED_TARGETS_FOLDER <span class="string">"cmake-default-targets"</span>)</span><br><span class="line"></span><br><span class="line">find_package(OpenCV REQUIRED )</span><br><span class="line">find_package(CUDA 6.0 REQUIRED ) # <span class="keyword">For</span> Cuda Managed Memory <span class="keyword">and</span> c++11</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> DEFINED CMAKE_CUDA_STANDARD)</span><br><span class="line">    <span class="builtin-name">set</span>(CMAKE_CUDA_STANDARD 11)</span><br><span class="line">    <span class="builtin-name">set</span>(CMAKE_CUDA_STANDARD_REQUIRED ON)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">include_directories(<span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span>)</span><br><span class="line">include_directories(.)</span><br><span class="line"></span><br><span class="line"><span class="comment"># from https://en.wikipedia.org/wiki/CUDA#GPUs_supported</span></span><br><span class="line"><span class="builtin-name">set</span>(CUDA_NVCC_FLAGS <span class="variable">$&#123;CUDA_NVCC_FLAGS&#125;</span>;-O3 --use_fast_math <span class="attribute">--ptxas-options</span>=-v --compiler-options -Wall -gencode <span class="attribute">arch</span>=compute_30,code=sm_30 -gencode <span class="attribute">arch</span>=compute_32,code=sm_32 -gencode <span class="attribute">arch</span>=compute_35,code=sm_35 -gencode <span class="attribute">arch</span>=compute_37,code=sm_37 -gencode <span class="attribute">arch</span>=compute_50,code=sm_50 -gencode <span class="attribute">arch</span>=compute_52,code=sm_52 -gencode <span class="attribute">arch</span>=compute_53,code=sm_53 -gencode <span class="attribute">arch</span>=compute_60,code=sm_60 -gencode <span class="attribute">arch</span>=compute_61,code=sm_61 -gencode <span class="attribute">arch</span>=compute_62,code=sm_62 -gencode <span class="attribute">arch</span>=compute_70,code=sm_70 -gencode <span class="attribute">arch</span>=compute_72,code=sm_72 -gencode <span class="attribute">arch</span>=compute_75,code=sm_75)</span><br><span class="line"><span class="comment">#set(CUDA_NVCC_FLAGS $&#123;CUDA_NVCC_FLAGS&#125;;-O3 --use_fast_math --ptxas-options=-v -std=c++11 --compiler-options -Wall -gencode arch=compute_52,code=sm_52)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(CMAKE_COMPILER_IS_GNUCXX)</span><br><span class="line">    add_definitions(<span class="attribute">-std</span>=c++11)</span><br><span class="line">    add_definitions(-Wall)</span><br><span class="line">    add_definitions(-Wextra)</span><br><span class="line">    add_definitions(-pedantic)</span><br><span class="line">    add_definitions(-Wno-unused-function)</span><br><span class="line">    <span class="builtin-name">set</span>(CMAKE_C_FLAGS_RELEASE <span class="string">"<span class="variable">$&#123;CMAKE_C_FLAGS_RELEASE&#125;</span> -O3 -ffast-math -march=native"</span>) # extend release-profile with fast-math</span><br><span class="line">    #add_definitions(<span class="attribute">-march</span>=native)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># for YouCompleteMe</span></span><br><span class="line"><span class="builtin-name">set</span>( CMAKE_EXPORT_COMPILE_COMMANDS 1 )</span><br><span class="line"></span><br><span class="line"><span class="comment"># For compilation ...</span></span><br><span class="line"><span class="comment"># Specify target &amp; source files to compile it from</span></span><br><span class="line">cuda_add_executable(</span><br><span class="line">    fusibile</span><br><span class="line">    cameraGeometryUtils.h</span><br><span class="line">    vector_operations.h</span><br><span class="line">    camera.h</span><br><span class="line">    globalstate.h</span><br><span class="line">    algorithmparameters.h</span><br><span class="line">    cameraparameters.h</span><br><span class="line">    linestate.h</span><br><span class="line">    displayUtils.h</span><br><span class="line">    mathUtils.h</span><br><span class="line">    fileIoUtils.h</span><br><span class="line">    fusibile.cu</span><br><span class="line">    main.cpp</span><br><span class="line">    )</span><br><span class="line"><span class="comment"># https://cliutils.gitlab.io/modern-cmake/chapters/packages/OpenMP.html</span></span><br><span class="line">find_package(OpenMP)</span><br><span class="line"></span><br><span class="line"><span class="comment"># For linking ...</span></span><br><span class="line"><span class="comment"># Specify target &amp; libraries to link it with</span></span><br><span class="line">target_link_libraries(fusibile</span><br><span class="line"><span class="variable">$&#123;OpenCV_LIBS&#125;</span></span><br><span class="line">OpenMP::OpenMP_CXX</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">include(FeatureSummary)</span><br><span class="line">feature_summary(WHAT ALL)</span><br></pre></td></tr></table></figure><h3 id="针对CMakeList-txt文件修改"><a class="header-anchor" href="#针对CMakeList-txt文件修改">¶</a>针对CMakeList.txt文件修改</h3><p>官方文件由于是14年的文件，那时候还不支持2080ti等算力的显卡。我通过<code>cmake .</code>和<code>make</code>编译得到的fusibile程序，运行报<code>no kernel image is available for execution on the device</code>的错误，因此为了兼容我的显卡以及多种其他算力不同cuda版本的显卡，我修改了CMAKELIST.txt文件。</p><p>将下面内容注释掉:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">set</span>(CUDA_NVCC_FLAGS <span class="variable">$&#123;CUDA_NVCC_FLAGS&#125;</span>;-O3 --use_fast_math <span class="attribute">--ptxas-options</span>=-v <span class="attribute">-std</span>=c++11 --compiler-options -Wall -gencode <span class="attribute">arch</span>=compute_52,code=sm_52)</span><br></pre></td></tr></table></figure><p>替换为了如下内容:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">set</span>(CUDA_NVCC_FLAGS <span class="variable">$&#123;CUDA_NVCC_FLAGS&#125;</span>;-O3 --use_fast_math <span class="attribute">--ptxas-options</span>=-v --compiler-options -Wall -gencode <span class="attribute">arch</span>=compute_30,code=sm_30 -gencode <span class="attribute">arch</span>=compute_32,code=sm_32 -gencode <span class="attribute">arch</span>=compute_35,code=sm_35 -gencode <span class="attribute">arch</span>=compute_37,code=sm_37 -gencode <span class="attribute">arch</span>=compute_50,code=sm_50 -gencode <span class="attribute">arch</span>=compute_52,code=sm_52 -gencode <span class="attribute">arch</span>=compute_53,code=sm_53 -gencode <span class="attribute">arch</span>=compute_60,code=sm_60 -gencode <span class="attribute">arch</span>=compute_61,code=sm_61 -gencode <span class="attribute">arch</span>=compute_62,code=sm_62 -gencode <span class="attribute">arch</span>=compute_70,code=sm_70 -gencode <span class="attribute">arch</span>=compute_72,code=sm_72 -gencode <span class="attribute">arch</span>=compute_75,code=sm_75)</span><br></pre></td></tr></table></figure><p>目前好像还不支持3090等30系显卡，但是20系显卡都支持了，后续的需要进行修改就好了.</p><h2 id="具体配置"><a class="header-anchor" href="#具体配置">¶</a>具体配置</h2><ul><li>将https://github.com/YoYo000/fusibile的代码clone下来</li><li>前提是配置好下面所需要的配置：CMAKE、OPenCV和CUDA</li><li>通过cmake.和make来安装fusible<ul><li>进入fusible文件夹</li><li>输入<code> cmake .</code>, 得到如下数据</li></ul></li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- The following OPTIONAL packages have been found:</span></span><br><span class="line"></span><br><span class="line"> * OpenMP</span><br><span class="line"></span><br><span class="line"><span class="comment">-- The following REQUIRED packages have been found:</span></span><br><span class="line"></span><br><span class="line"> * OpenCV</span><br><span class="line"> * Threads</span><br><span class="line"> * CUDA (required <span class="keyword">version</span> &gt;= <span class="number">6.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Configuring done</span></span><br><span class="line"><span class="comment">-- Generating done</span></span><br><span class="line"><span class="comment">-- Build files have been written to: /file/sync_files/FasterMVSNet/fusible</span></span><br></pre></td></tr></table></figure><ul><li>输入make, 编译完成之后文件夹会出现一个fusible文件没有后缀，表示成功了。</li><li>如果需要的话，需要使用如下命令来清除缓存</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf <span class="module-access"><span class="module"><span class="identifier">CMakeCache</span>.</span></span>txt</span><br></pre></td></tr></table></figure><h2 id="Linux安装CMAKE"><a class="header-anchor" href="#Linux安装CMAKE">¶</a>Linux安装CMAKE</h2><ol><li>通过如下命令查看Linux位数</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">getconf LONG_BIT</span></span><br></pre></td></tr></table></figure><ol start="2"><li>获取cmake源码包，先创了一个文件夹来存储cmake, 根据官方配置需求文件，得到我们需要一个CMAKE版本大于3.9</li></ol><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mkdir</span> <span class="keyword">app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cd</span> <span class="keyword">app</span></span><br></pre></td></tr></table></figure><p>然后要去CMAKE<a href="https://cmake.org/download/">官网</a>去获取对应的CMAKE链接, 使用如下命令下载:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget install https:<span class="regexp">//gi</span>thub.com<span class="regexp">/Kitware/</span>CMake<span class="regexp">/releases/</span>download<span class="regexp">/v3.21.2/</span>cmake-<span class="number">3.21</span>.<span class="number">2</span>.tar.gz</span><br></pre></td></tr></table></figure><p>这里我下载的是3.21版本的CMAKE.</p><ol start="3"><li>解压源码</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tar</span> <span class="selector-tag">xzvf</span> <span class="selector-tag">cmake-3</span><span class="selector-class">.21</span><span class="selector-class">.2</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure><ol start="4"><li>安装gcc(Ubuntu使用apt-get安装，Linux使用yum安装)</li></ol><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Ubuntu</span></span><br><span class="line">apt-<span class="keyword">get</span> install gcc</span><br><span class="line"></span><br><span class="line"><span class="meta"># Linux</span></span><br><span class="line">yum install gcc-c++</span><br></pre></td></tr></table></figure><ol start="5"><li>安装cmake，先进入解压后的cmake的目录</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd cmake<span class="number">-3.21</span><span class="number">.2</span></span><br><span class="line"></span><br><span class="line">./bootstrap</span><br></pre></td></tr></table></figure><p>如果编译出现如下信息:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Could <span class="keyword">NOT</span> <span class="builtin-name">find</span> OpenSSL</span><br></pre></td></tr></table></figure><p>Ubuntu系统可以执行如下命令安装相关依赖:</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br><span class="line">apt-<span class="built_in">get</span> install libssl-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure><p>安装完成之后再重新编译就好了。</p><ol start="6"><li>在当前目录执行如下命令安装make</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make <span class="keyword">install</span></span><br></pre></td></tr></table></figure><ol start="7"><li>完成之后使用如下命令查看cmake版本</li></ol><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake <span class="comment">--version</span></span><br></pre></td></tr></table></figure><h2 id="Linux安装OpenCV"><a class="header-anchor" href="#Linux安装OpenCV">¶</a>Linux安装OpenCV</h2><ol><li>按照之前的步骤安装完cmake</li><li>安装依赖环境</li></ol><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="built_in">get</span> install build-essential libgtk2<span class="number">.0</span>-<span class="built_in">dev</span> libavcodec-<span class="built_in">dev</span> libavformat-<span class="built_in">dev</span> libjpeg-<span class="built_in">dev</span> libswscale-<span class="built_in">dev</span> libtiff5-<span class="built_in">dev</span></span><br><span class="line"></span><br><span class="line">apt-<span class="built_in">get</span> install libgtk2<span class="number">.0</span>-<span class="built_in">dev</span></span><br><span class="line"></span><br><span class="line">apt-<span class="built_in">get</span> install pkg-config</span><br></pre></td></tr></table></figure><ol start="3"><li>去OpenCV<a href="https://opencv.org/releases/">官网</a>下载源码，这里我是将源码下载下来，然后在上传到服务器上的，可以使用wget来进行源码的下载，命令如下:</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget install https:<span class="regexp">//gi</span>thub.com<span class="regexp">/opencv/</span>opencv<span class="regexp">/archive/</span><span class="number">4.5</span>.<span class="number">3</span>.zip</span><br></pre></td></tr></table></figure><ol start="4"><li>解压完文件</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">unzip</span> <span class="selector-tag">-n</span> <span class="selector-tag">opencv-4</span><span class="selector-class">.5</span><span class="selector-class">.3</span><span class="selector-class">.zip</span></span><br></pre></td></tr></table></figure><ol start="5"><li>解压完文件之后，进入目录，创建build目录</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd opencv<span class="number">-4.5</span><span class="number">.3</span></span><br><span class="line"></span><br><span class="line">mkdir build</span><br></pre></td></tr></table></figure><ol start="6"><li>使用如下命令清除CMakeCache缓存</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf <span class="module-access"><span class="module"><span class="identifier">CMakeCache</span>.</span></span>txt</span><br></pre></td></tr></table></figure><p>这个方法是进入到build文件夹之后，使用cmake出现如下错误时使用:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMake Error: The source directory <span class="string">"/file/app/opencv-4.5.3/build"</span> <span class="keyword">does</span> <span class="keyword">not</span> appear <span class="keyword">to</span> <span class="keyword">contain</span> CMakeLists.txt.</span><br></pre></td></tr></table></figure><ol start="7"><li>进入build文件夹，使用cmake命令</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -D <span class="attribute">CMAKE_BUILD_TYPE</span>=Release -D <span class="attribute">CMAKE_INSTALL_PREFIX</span>=/usr/local <span class="built_in">..</span></span><br></pre></td></tr></table></figure><p>如果安装了Anaconda建议使用如下命令:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -D <span class="attribute">CMAKE_BUILD_TYPE</span>=RELEASE -D <span class="attribute">CMAKE_INSTALL_PREFIX</span>=/usr/local -D <span class="attribute">WITH_TBB</span>=ON -D <span class="attribute">BUILD_SHARED_LIBS</span>=OFF -D <span class="attribute">WITH_OPENMP</span>=ON -D <span class="attribute">ENABLE_PRECOMPILED_HEADERS</span>=OFF <span class="built_in">..</span></span><br></pre></td></tr></table></figure><p>切记不能在cmake配置下面的环境变量，否则会报错！！！<br>类似下面这种</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Some</span> <span class="selector-tag">of</span> <span class="selector-tag">these</span> <span class="selector-tag">libraries</span> <span class="selector-tag">may</span> <span class="selector-tag">not</span> <span class="selector-tag">be</span> <span class="selector-tag">found</span> <span class="selector-tag">correctly</span>. <span class="selector-tag">Call</span> <span class="selector-tag">Stack</span> (most recent call first):   <span class="selector-tag">cmake</span>/<span class="selector-tag">OpenCVModule</span><span class="selector-class">.cmake</span><span class="selector-pseudo">:1273</span> (ocv_add_executable)   <span class="selector-tag">modules</span>/<span class="selector-tag">highgui</span>/<span class="selector-tag">CMakeLists</span><span class="selector-class">.txt</span><span class="selector-pseudo">:272</span> (ocv_add_accuracy_tests)</span><br></pre></td></tr></table></figure><ol start="8"><li>执行结束之后，在使用make进行编译</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span> -j8</span><br></pre></td></tr></table></figure><ol start="9"><li>使用如下命令进行安装</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make <span class="keyword">install</span></span><br></pre></td></tr></table></figure><ol start="10"><li>配置环境，使用vim打开/etc/ld.so.conf，在最后一行加上/usr/local/lib</li></ol><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ld.so.conf</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> /usr/local/<span class="class"><span class="keyword">lib</span></span></span><br></pre></td></tr></table></figure><p>然后运行如下命令生效:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ldconfig</span></span><br></pre></td></tr></table></figure><ol start="11"><li>修改bash.bashrc文件</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim <span class="regexp">/etc/</span>bash.bashrc</span><br></pre></td></tr></table></figure><p>在文件末尾添加上如下内容:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PKG_CONFIG_PATH=$<span class="symbol">PKG_CONFIG_PATH:</span>/usr/local/<span class="class"><span class="keyword">lib</span>/<span class="title">pkgconfig</span></span></span><br><span class="line">export PKG_CONFIG_PATH</span><br></pre></td></tr></table></figure><p>然后在命令输入如下命令生效:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">source</span> <span class="regexp">/etc/</span>bash.bashrc</span><br></pre></td></tr></table></figure><ol start="12"><li>检查是否生效</li></ol><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/<span class="class"><span class="keyword">lib</span></span></span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p><img src="http://image-storage-zs.test.upcdn.net/stu0IU.png" alt="figure.1"></p><h2 id="问题"><a class="header-anchor" href="#问题">¶</a>问题</h2><h3 id="报错GL-gl-h-No-such-file-or-directory"><a class="header-anchor" href="#报错GL-gl-h-No-such-file-or-directory">¶</a>报错GL/gl.h: No such file or directory</h3><p>使用如下命令安装:</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install mesa-common-<span class="built_in">dev</span></span><br><span class="line">sudo apt-<span class="built_in">get</span> install libgl1-mesa-<span class="built_in">dev</span> libglu1-mesa-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;MVSNet depthfusion配置流程&lt;/h1&gt;
&lt;h2 id=&quot;原文内容&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#原文内容&quot;&gt;¶&lt;/a&gt;原文内容&lt;/h2&gt;
&lt;p&gt;R/MVSNet itself only produces per-view
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>LeetCode No.166</title>
    <link href="www.strivezs.com/2022/02/20/LeetCode%E7%AC%AC166%E9%A2%98/"/>
    <id>www.strivezs.com/2022/02/20/LeetCode%E7%AC%AC166%E9%A2%98/</id>
    <published>2022-02-20T13:37:26.564Z</published>
    <updated>2022-02-20T13:37:26.564Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第166题—分数到小数</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><p>好久没更新了 忙于科研来着 害 都是为了毕业。最近又把自己的事情捡起来了。</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以 字符串形式返回小数 。</p><p>如果小数部分为循环小数，则将循环的部分括在括号内。</p><p>如果存在多个答案，只需返回 任意一个 。</p><p>对于所有给定的输入，保证 答案字符串的长度小于 104 。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：numerator = <span class="number">1</span>, denominator = <span class="number">2</span></span><br><span class="line">输出：<span class="string">"0.5"</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：numerator = <span class="number">2</span>, denominator = <span class="number">1</span></span><br><span class="line">输出：<span class="string">"2"</span></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：numerator = <span class="number">2</span>, denominator = <span class="number">3</span></span><br><span class="line">输出：<span class="string">"0.(6)"</span></span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：numerator = <span class="number">4</span>, denominator = <span class="number">333</span></span><br><span class="line">输出：<span class="string">"0.(012)"</span></span><br><span class="line">示例 <span class="number">5</span>：</span><br><span class="line"></span><br><span class="line">输入：numerator = <span class="number">1</span>, denominator = <span class="number">5</span></span><br><span class="line">输出：<span class="string">"0.2"</span></span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-231</span> &lt;= numerator, denominator &lt;= <span class="number">231</span> - <span class="number">1</span></span><br><span class="line">denominator != <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>思路: 就是模拟大数除法的过程，结合上队列来实现重复被除数查询，从而实现括号的添加。特别注意负数和整除的情况</p><p>代码如下:(其中第一个想法是只针对比较单一的情况)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># @lc app=leetcode.cn id=166 lang=python</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># [166] 分数到小数</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># @lc code=start</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fractionToDecimal</span><span class="params">(self, numerator, denominator)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        除法运算, 实质为:寻找重复位数</span></span><br><span class="line"><span class="string">        分两种情况来进行判断:</span></span><br><span class="line"><span class="string">            1. 直接整除的情况，直接转换为小数就可以了</span></span><br><span class="line"><span class="string">            2. 不能整除，小数部分为循环小数的情况。</span></span><br><span class="line"><span class="string">        整体做法均为要用代码实现出发运算过程，包括借位等操作</span></span><br><span class="line"><span class="string">        针对循环小数的情况：</span></span><br><span class="line"><span class="string">            1. 最简单的就是2/3 4/3等这种单位循环的小数 0.(6) 1.(6)等等 这种通过下面Version1的代码就可以实现（只需要判断当前被除数和上个被除数是否相同即可了）</span></span><br><span class="line"><span class="string">            但是这个不适用于4/333的情况，因为它是多位小数循环的情况，单凭上面的思路无法实现</span></span><br><span class="line"><span class="string">            2. 因此我考虑了新的方法，建立一个队列存储生成的被除数，只要在点了小数点之后就是将所有的被除数存储，然后累积存储被除数直到重复，则将对应重复被除数之间的所有小数点位数用括号括起来</span></span><br><span class="line"><span class="string">        :type numerator: int</span></span><br><span class="line"><span class="string">        :type denominator: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 判断是否能够整除</span></span><br><span class="line">        <span class="keyword">if</span> numerator % denominator == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> str(numerator / denominator)</span><br><span class="line">        <span class="comment"># 思路一</span></span><br><span class="line">        <span class="comment">## 模拟除法运算</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        res = '' # 保存结果</span></span><br><span class="line"><span class="string">        flag = True # 标志着重复 被除数连着两次重复</span></span><br><span class="line"><span class="string">        flag1 = False # 标志小数点使用了</span></span><br><span class="line"><span class="string">        pre_div = numerator # 存储上一个被除数 当上一个被除数和当前被除数</span></span><br><span class="line"><span class="string">        trade = 0 # 商</span></span><br><span class="line"><span class="string">        while flag:</span></span><br><span class="line"><span class="string">            trade = int(numerator / denominator)</span></span><br><span class="line"><span class="string">            if trade == 0:</span></span><br><span class="line"><span class="string">                if res == '': # 单独处理2/3商为0的情况</span></span><br><span class="line"><span class="string">                    res = '0'</span></span><br><span class="line"><span class="string">                    res += '.'</span></span><br><span class="line"><span class="string">                    flag1 = True</span></span><br><span class="line"><span class="string">                else:</span></span><br><span class="line"><span class="string">                    #res += str(trade)</span></span><br><span class="line"><span class="string">                    if '.' not in res:</span></span><br><span class="line"><span class="string">                        res += '.'</span></span><br><span class="line"><span class="string">                        flag1 = True</span></span><br><span class="line"><span class="string">                pre_div = numerator</span></span><br><span class="line"><span class="string">                numerator = numerator * 10 - trade * denominator</span></span><br><span class="line"><span class="string">            else:</span></span><br><span class="line"><span class="string">                res += str(trade)</span></span><br><span class="line"><span class="string">                pre_div = numerator</span></span><br><span class="line"><span class="string">                numerator = numerator - trade * denominator</span></span><br><span class="line"><span class="string">                if flag1:</span></span><br><span class="line"><span class="string">                    numerator = numerator * 10</span></span><br><span class="line"><span class="string">            if pre_div == numerator:</span></span><br><span class="line"><span class="string">                res = res[:-1] + '(' + res[-1] + ')'</span></span><br><span class="line"><span class="string">                break</span></span><br><span class="line"><span class="string">            if numerator == 0:</span></span><br><span class="line"><span class="string">                break</span></span><br><span class="line"><span class="string">        return res</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 思路二</span></span><br><span class="line">        <span class="comment">## 模拟除法运算+被除数队列记忆</span></span><br><span class="line">        <span class="comment"># 负数处理</span></span><br><span class="line">        flag2 = <span class="literal">False</span> <span class="comment"># 负数标志</span></span><br><span class="line">        <span class="keyword">if</span> numerator &lt; <span class="number">0</span> <span class="keyword">and</span> denominator &lt; <span class="number">0</span>:</span><br><span class="line">            numerator = abs(numerator)</span><br><span class="line">            denominator = abs(denominator)</span><br><span class="line">        <span class="keyword">elif</span> numerator &lt; <span class="number">0</span>:</span><br><span class="line">            numerator = abs(numerator)</span><br><span class="line">            flag2 = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> denominator &lt; <span class="number">0</span>:</span><br><span class="line">            denominator = abs(denominator)</span><br><span class="line">            flag2 = <span class="literal">True</span></span><br><span class="line">        res = <span class="string">''</span> <span class="comment"># 结果保存</span></span><br><span class="line">        flag = <span class="literal">True</span> <span class="comment"># 标志是否结束</span></span><br><span class="line">        flag1 = <span class="literal">False</span> <span class="comment"># 标志小数点使用了</span></span><br><span class="line">        numerator_list = [] <span class="comment"># 存储被除数的list</span></span><br><span class="line">        trade = <span class="number">0</span> <span class="comment"># 商</span></span><br><span class="line">        <span class="keyword">while</span> flag:</span><br><span class="line">            trade = int(numerator / denominator)</span><br><span class="line">            <span class="keyword">if</span> trade == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> res == <span class="string">''</span>: <span class="comment"># 单独处理2/3商为0的情况</span></span><br><span class="line">                    res = <span class="string">'0'</span></span><br><span class="line">                    res += <span class="string">'.'</span></span><br><span class="line">                    flag1 = <span class="literal">True</span></span><br><span class="line">                    numerator = numerator * <span class="number">10</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment">#res += str(trade)</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="string">'.'</span> <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                        res += <span class="string">'.'</span></span><br><span class="line">                        flag1 = <span class="literal">True</span></span><br><span class="line">                        numerator = numerator * <span class="number">10</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        res += <span class="string">'0'</span></span><br><span class="line">                        numerator_list.append(numerator)</span><br><span class="line">                        numerator = numerator * <span class="number">10</span> - trade * denominator</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += str(trade)</span><br><span class="line">                <span class="keyword">if</span> <span class="string">'.'</span> <span class="keyword">in</span> res:</span><br><span class="line">                    numerator_list.append(numerator)</span><br><span class="line">                numerator = numerator - trade * denominator</span><br><span class="line">                <span class="keyword">if</span> flag1:</span><br><span class="line">                    numerator = numerator * <span class="number">10</span></span><br><span class="line">            <span class="comment"># 如果numerator在numerator_list中，则证明重复了</span></span><br><span class="line">            <span class="keyword">if</span> numerator <span class="keyword">in</span> numerator_list:</span><br><span class="line">                <span class="comment"># 分两种情况，第一种是单位重复，第二种是多位重复</span></span><br><span class="line">                <span class="comment"># 单位重复</span></span><br><span class="line">                <span class="keyword">if</span> numerator == numerator_list[<span class="number">-1</span>]:</span><br><span class="line">                    res = res[:<span class="number">-1</span>] + <span class="string">'('</span> + res[<span class="number">-1</span>] + <span class="string">')'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 多位重复</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    index = numerator_list.index(numerator) <span class="comment"># 找到重复被除数的下标</span></span><br><span class="line">                    point_index = res.index(<span class="string">'.'</span>) <span class="comment"># 找到小数点的位数</span></span><br><span class="line">                    offset = <span class="number">2</span> <span class="comment"># 偏移量</span></span><br><span class="line">                    <span class="keyword">if</span> len(res[:point_index]) != <span class="number">1</span>:</span><br><span class="line">                        offset = point_index + <span class="number">1</span></span><br><span class="line">                    res = res[: index+offset] + <span class="string">'('</span> + res[index+offset:] + <span class="string">')'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> numerator == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> flag2:</span><br><span class="line">            res = <span class="string">'-'</span> + res</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">print(s.fractionToDecimal(numerator = <span class="number">420</span>, denominator = <span class="number">226</span>))</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># @lc code=end</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第166题—分数到小数&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.165</title>
    <link href="www.strivezs.com/2021/08/09/LeetCode%E7%AC%AC165%E9%A2%98/"/>
    <id>www.strivezs.com/2021/08/09/LeetCode%E7%AC%AC165%E9%A2%98/</id>
    <published>2021-08-09T00:48:07.000Z</published>
    <updated>2021-08-09T00:48:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第165题—比较版本号</h1><p>最近科研有点忙，两天可能才更新一下。www</p><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你两个版本号 version1 和 version2 ，请你比较它们。</p><p>版本号由一个或多个修订号组成，各修订号由一个 ‘.’ 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。</p><p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。</p><p>返回规则如下：</p><p>如果 version1 &gt; version2 返回 1，<br>如果 version1 &lt; version2 返回 -1，<br>除此之外返回 0。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：<span class="keyword">version</span>1 = <span class="string">"1.01"</span>, <span class="keyword">version</span>2 = <span class="string">"1.001"</span></span><br><span class="line">输出：0</span><br><span class="line">解释：忽略前导零，<span class="string">"01"</span> 和 <span class="string">"001"</span> 都表示相同的整数 <span class="string">"1"</span></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：<span class="keyword">version</span>1 = <span class="string">"1.0"</span>, <span class="keyword">version</span>2 = <span class="string">"1.0.0"</span></span><br><span class="line">输出：0</span><br><span class="line">解释：<span class="keyword">version</span>1 没有指定下标为 2 的修订号，即视为 <span class="string">"0"</span></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：<span class="keyword">version</span>1 = <span class="string">"0.1"</span>, <span class="keyword">version</span>2 = <span class="string">"1.1"</span></span><br><span class="line">输出：-1</span><br><span class="line">解释：<span class="keyword">version</span>1 中下标为 0 的修订号是 <span class="string">"0"</span>，<span class="keyword">version</span>2 中下标为 0 的修订号是 <span class="string">"1"</span> 。0 &lt; 1，所以 <span class="keyword">version</span>1 &lt; <span class="keyword">version</span>2</span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：<span class="keyword">version</span>1 = <span class="string">"1.0.1"</span>, <span class="keyword">version</span>2 = <span class="string">"1"</span></span><br><span class="line">输出：1</span><br><span class="line">示例 5：</span><br><span class="line"></span><br><span class="line">输入：<span class="keyword">version</span>1 = <span class="string">"7.5.2.4"</span>, <span class="keyword">version</span>2 = <span class="string">"7.5.3"</span></span><br><span class="line">输出：-1</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;= <span class="keyword">version</span>1.length, <span class="keyword">version</span>2.length &lt;= 500</span><br><span class="line"><span class="keyword">version</span>1 和 <span class="keyword">version</span>2 仅包含数字和 '.'</span><br><span class="line"><span class="keyword">version</span>1 和 <span class="keyword">version</span>2 都是 有效版本号</span><br><span class="line"><span class="keyword">version</span>1 和 <span class="keyword">version</span>2 的所有修订号都可以存储在 32 位整数 中</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># @lc app=leetcode.<span class="keyword">cn</span> id=<span class="number">165</span> lang=<span class="keyword">python</span></span><br><span class="line">#</span><br><span class="line"># [<span class="number">165</span>] 比较版本号</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># @lc code=start</span><br><span class="line">class Solution(object):</span><br><span class="line">    def compareVersion(self, version1, version2):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        用<span class="keyword">split</span>划分 转换为<span class="keyword">int</span> 比较即可</span><br><span class="line">        :<span class="built_in">type</span> version1: str</span><br><span class="line">        :<span class="built_in">type</span> version2: str</span><br><span class="line">        :rtype: <span class="keyword">int</span></span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        com1 = version1.<span class="keyword">split</span>(<span class="string">'.'</span>)</span><br><span class="line">        com2 = version2.<span class="keyword">split</span>(<span class="string">'.'</span>)</span><br><span class="line">        # 排除特殊情况</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(com1) != <span class="built_in">len</span>(com2):</span><br><span class="line">            # 单独处理 <span class="number">1.0</span> <span class="number">1.0</span>.<span class="number">0</span>的情况</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(com1) &gt; <span class="built_in">len</span>(com2):</span><br><span class="line">                <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(com2)):</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">int</span>(com1[i]) &gt; <span class="keyword">int</span>(com2[i]):</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">                    elif <span class="keyword">int</span>(com1[i]) &lt; <span class="keyword">int</span>(com2[i]):</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(com2), <span class="built_in">len</span>(com1)):</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">int</span>(com1[i]) != <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(com1)):</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">int</span>(com1[i]) &gt; <span class="keyword">int</span>(com2[i]):</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">                    elif <span class="keyword">int</span>(com1[i]) &lt; <span class="keyword">int</span>(com2[i]):</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(com1), <span class="built_in">len</span>(com2)):</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">int</span>(com2[i]) != <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        # 长度相同的情况</span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(com1)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">int</span>(com1[i]) &gt; <span class="keyword">int</span>(com2[i]):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            elif <span class="keyword">int</span>(com1[i]) &lt; <span class="keyword">int</span>(com2[i]):</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"># @lc code=end</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第165题—比较版本号&lt;/h1&gt;
&lt;p&gt;最近科研有点忙，两天可能才更新一下。www&lt;/p&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.164</title>
    <link href="www.strivezs.com/2021/08/06/LeetCode%E7%AC%AC164%E9%A2%98/"/>
    <id>www.strivezs.com/2021/08/06/LeetCode%E7%AC%AC164%E9%A2%98/</id>
    <published>2021-08-06T01:42:20.000Z</published>
    <updated>2021-08-06T01:42:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第164题—最大间距</h1><p>各种排序我后面一定补上，大雾</p><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。</p><p>如果数组元素个数小于 2，则返回 0。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 排序后的数组是 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>], 其中相邻元素 (<span class="number">3</span>,<span class="number">6</span>) 和 (<span class="number">6</span>,<span class="number">9</span>) 之间都存在最大差值 <span class="number">3</span>。</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="number">10</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 数组元素个数小于 <span class="number">2</span>，因此返回 <span class="number">0</span>。</span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">你可以假设数组中所有元素都是非负整数，且数值在 <span class="number">32</span> 位有符号整数范围内。</span><br><span class="line">请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># @lc app=leetcode.<span class="keyword">cn</span> id=<span class="number">164</span> lang=<span class="keyword">python</span></span><br><span class="line">#</span><br><span class="line"># [<span class="number">164</span>] 最大间距</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># @lc code=start</span><br><span class="line"></span><br><span class="line">class Solution(object):</span><br><span class="line">    def time_out(self, nums):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        题目要求在线性时间复杂度和空间复杂度上解决这个问题，因此最常用的排序之后在寻找最大间距大概率Time out不推荐，考虑其他方法</span><br><span class="line">        [<span class="number">3</span> <span class="number">9</span> <span class="number">6</span> <span class="number">1</span>] 线性复杂度的话，还是要考虑动态更新的问题，最好边排序边把最大间隔找出来，因此不仅要记录每个数字对应的最大间隔，还要找到全局最大的间隔</span><br><span class="line">        那就考虑使用字典结构分别存储每个数值的最大间隔，然后每次更新最大间隔的话，</span><br><span class="line">        最后更新全局最大间隔</span><br><span class="line">        还有一点就是要找到线性时间排序的算法，即复杂度为<span class="keyword">o</span>(n)</span><br><span class="line">        根据网上的内容目前三种主要的线性时间排序算法分别为: <span class="number">1</span>.计数排序 <span class="number">2</span>.基数排序 <span class="number">3</span>.桶排序</span><br><span class="line">        - 计数排序的思想: 对每一个输入元素<span class="keyword">x</span>，确定小于<span class="keyword">x</span>的个数，这样就可以把<span class="keyword">x</span>直接放在它最终输出数组的位置上</span><br><span class="line">        - 桶排序的思想: 将数组分到有限数量的桶子里，每个桶子在个别排序，当要被排序数组的数值是均匀分配的时候，桶排序可以是线性时间运行的</span><br><span class="line">        - 基数排序的思想: 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。需要注意的是，对每一个数位进行排序的算法必须是稳定的，否则就会取消前一次排序的结果。通常我们使用计数排序或者桶排序作为基数排序的辅助算法</span><br><span class="line">        </span><br><span class="line">        这里我先使用插入排序来实现本问题，后续如果有时间的话，再学习一下上述三种线性时间排序</span><br><span class="line">        插入排序裂开了，直接timeout</span><br><span class="line">        :<span class="built_in">type</span> num<span class="variable">s:</span> List[<span class="keyword">int</span>]</span><br><span class="line">        :rtype: <span class="keyword">int</span></span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        # 特殊情况</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> <span class="built_in">or</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        # num_interval = dict()</span><br><span class="line">        # 选择排序</span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            # num_interval[nums[i]] = <span class="number">0</span></span><br><span class="line">            t = i</span><br><span class="line">            <span class="keyword">for</span> <span class="keyword">j</span> in <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[t] &gt; nums[<span class="keyword">j</span>]:</span><br><span class="line">                    t = <span class="keyword">j</span></span><br><span class="line">            temp = nums[t]</span><br><span class="line">            nums[t] = nums[i]</span><br><span class="line">            nums[i] = temp</span><br><span class="line">            # # 更新所有数字的间隔</span><br><span class="line">            # <span class="keyword">for</span> <span class="keyword">m</span> in <span class="built_in">range</span>(<span class="number">0</span>, i+<span class="number">1</span>):</span><br><span class="line">            #     <span class="keyword">if</span> <span class="keyword">m</span> == <span class="number">0</span>:</span><br><span class="line">            #         num_interval[nums[<span class="keyword">m</span>]] = <span class="built_in">abs</span>(nums[<span class="number">1</span>] - nums[<span class="number">0</span>])</span><br><span class="line">            #     elif <span class="keyword">m</span> == <span class="built_in">len</span>(nums)-<span class="number">1</span>:</span><br><span class="line">            #         num_interval[nums[<span class="keyword">m</span>]] = <span class="built_in">abs</span>(nums[<span class="keyword">m</span>] - nums[<span class="keyword">m</span>-<span class="number">1</span>])</span><br><span class="line">            #     <span class="keyword">else</span>:</span><br><span class="line">            #         num_interval[nums[<span class="keyword">m</span>]] = <span class="built_in">max</span>(<span class="built_in">abs</span>(nums[<span class="keyword">m</span>] - nums[<span class="keyword">m</span>-<span class="number">1</span>]), <span class="built_in">abs</span>(nums[<span class="keyword">m</span>] - nums[<span class="keyword">m</span>+<span class="number">1</span>]))</span><br><span class="line">            max_interval = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                max_interval = <span class="built_in">max</span>(max_interval, <span class="built_in">abs</span>(nums[<span class="number">1</span>] - nums[<span class="number">0</span>]))</span><br><span class="line">            elif i ==<span class="built_in">len</span>(nums)-<span class="number">1</span>:</span><br><span class="line">                max_interval = <span class="built_in">max</span>(max_interval, <span class="built_in">abs</span>(nums[i] - nums[i-<span class="number">1</span>]))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                max_interval = <span class="built_in">max</span>(max_interval, <span class="built_in">max</span>(<span class="built_in">abs</span>(nums[i] - nums[i-<span class="number">1</span>]), <span class="built_in">abs</span>(nums[i] - nums[i+<span class="number">1</span>])))</span><br><span class="line">        # <span class="keyword">return</span> num_interval[<span class="built_in">max</span>(num_interval,key=num_interval.<span class="built_in">get</span>)]</span><br><span class="line">        <span class="keyword">return</span> max_interval</span><br><span class="line">    def maximumGap(self, nums):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        <span class="keyword">python</span>中的sorted好像就是桶排序，这里偷懒直接用了，后面要去学习一下桶排序QAQ</span><br><span class="line">        各种排序方法后面一定从头不上呜呜呜</span><br><span class="line">        :<span class="built_in">type</span> num<span class="variable">s:</span> List[<span class="keyword">int</span>]</span><br><span class="line">        :rtype: <span class="keyword">int</span></span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        # 特殊情况</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> <span class="built_in">or</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        max_interval = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                max_interval = <span class="built_in">max</span>(max_interval, <span class="built_in">abs</span>(nums[<span class="number">1</span>] - nums[<span class="number">0</span>]))</span><br><span class="line">            elif i ==<span class="built_in">len</span>(nums)-<span class="number">1</span>:</span><br><span class="line">                max_interval = <span class="built_in">max</span>(max_interval, <span class="built_in">abs</span>(nums[i] - nums[i-<span class="number">1</span>]))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                max_interval = <span class="built_in">max</span>(max_interval, <span class="built_in">max</span>(<span class="built_in">abs</span>(nums[i] - nums[i-<span class="number">1</span>]), <span class="built_in">abs</span>(nums[i] - nums[i+<span class="number">1</span>])))</span><br><span class="line">        <span class="keyword">return</span> max_interval</span><br><span class="line"># @lc code=end</span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="keyword">print</span>(s.maximumGap([<span class="number">3</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">6</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第164题—最大间距&lt;/h1&gt;
&lt;p&gt;各种排序我后面一定补上，大雾&lt;/p&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.160</title>
    <link href="www.strivezs.com/2021/08/05/LeetCode%E7%AC%AC160%E9%A2%98/"/>
    <id>www.strivezs.com/2021/08/05/LeetCode%E7%AC%AC160%E9%A2%98/</id>
    <published>2021-08-05T01:16:44.000Z</published>
    <updated>2021-08-05T01:16:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第160题—相交链表</h1><p>我真的菜死了QAQ，这道题写了半个多小时才写出来，一道简单题  我气哦。因为没有plus会员，我还是老实的刷免费的吧。</p><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p><p>图示两个链表在节点 c1 开始相交：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="figure.0"></p><p>题目数据 保证 整个链式结构中不存在环。</p><p>注意，函数返回结果后，链表必须 保持其原始结构 。</p><p></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">int</span>ersectVal = <span class="number">8</span>, listA = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>], listB = [<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>], skipA = <span class="number">2</span>, skipB = <span class="number">3</span></span><br><span class="line">输出：Intersected at <span class="string">'8'</span></span><br><span class="line">解释：相交节点的值为 <span class="number">8</span> （注意，如果两个链表相交则不能为 <span class="number">0</span>）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]，链表 B 为 [<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]。</span><br><span class="line">在 A 中，相交节点前有 <span class="number">2</span> 个节点；在 B 中，相交节点前有 <span class="number">3</span> 个节点。</span><br><span class="line">示例 <span class="number">2</span>：</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png" alt="figure.2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">int</span>ersectVal = <span class="number">2</span>, listA = [<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>], listB = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>], skipA = <span class="number">3</span>, skipB = <span class="number">1</span></span><br><span class="line">输出：Intersected at <span class="string">'2'</span></span><br><span class="line">解释：相交节点的值为 <span class="number">2</span> （注意，如果两个链表相交则不能为 <span class="number">0</span>）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]，链表 B 为 [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]。</span><br><span class="line">在 A 中，相交节点前有 <span class="number">3</span> 个节点；在 B 中，相交节点前有 <span class="number">1</span> 个节点。</span><br><span class="line">示例 <span class="number">3</span>：</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="figure.3"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">int</span>ersectVal = <span class="number">0</span>, listA = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>], listB = [<span class="number">1</span>,<span class="number">5</span>], skipA = <span class="number">3</span>, skipB = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">null</span></span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>]，链表 B 为 [<span class="number">1</span>,<span class="number">5</span>]。</span><br><span class="line">由于这两个链表不相交，所以 <span class="built_in">int</span>ersectVal 必须为 <span class="number">0</span>，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 <span class="literal">null</span> 。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">listA 中节点数目为 m</span><br><span class="line">listB 中节点数目为 n</span><br><span class="line"><span class="number">0</span> &lt;= m, n &lt;= <span class="number">3</span> * <span class="number">104</span></span><br><span class="line"><span class="number">1</span> &lt;= Node.val &lt;= <span class="number">105</span></span><br><span class="line"><span class="number">0</span> &lt;= skipA &lt;= m</span><br><span class="line"><span class="number">0</span> &lt;= skipB &lt;= n</span><br><span class="line">如果 listA 和 listB 没有交点，<span class="built_in">int</span>ersectVal 为 <span class="number">0</span></span><br><span class="line">如果 listA 和 listB 有交点，<span class="built_in">int</span>ersectVal == listA[skipA + <span class="number">1</span>] == listB[skipB + <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">timeout</span><span class="params">(self, headA, headB)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        考虑用list分别分出两个head出现的节点, 然后遍历就好了 直到有首个重复的节点结束</span></span><br><span class="line"><span class="string">        :type head1, head1: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        listA = [] <span class="comment"># 专门存储A的节点</span></span><br><span class="line">        listB = [] <span class="comment"># 专门存储B的节点</span></span><br><span class="line">        <span class="keyword">while</span> headA != <span class="literal">None</span> <span class="keyword">or</span> headB != <span class="literal">None</span>:</span><br><span class="line">            listA.append(headA)</span><br><span class="line">            listB.append(headB)</span><br><span class="line">            <span class="keyword">if</span> headB <span class="keyword">in</span> listA:</span><br><span class="line">                <span class="keyword">return</span> headB</span><br><span class="line">            <span class="keyword">if</span> headA <span class="keyword">in</span> listB:</span><br><span class="line">                <span class="keyword">return</span> headA</span><br><span class="line">            <span class="keyword">if</span> headA != <span class="literal">None</span>:</span><br><span class="line">                headA = headA.next</span><br><span class="line">            <span class="keyword">if</span> headB != <span class="literal">None</span>:</span><br><span class="line">                headB = headB.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA, headB)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        参考了一下大佬的思路，由于两个链表长度不相同，但是可以使用另外一种办法让他们的长度变得一样长</span></span><br><span class="line"><span class="string">        让两个head同时出发，如果其中一个head走到头了，则开始走另一个head的路，这样两条路长度就一样了，就会在同一个点相同，有点类似莫比乌斯环的感觉后面给图示</span></span><br><span class="line"><span class="string">        :type head1, head1: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> headA <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> headB <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 开始走</span></span><br><span class="line">        h1 = headA</span><br><span class="line">        h2 = headB</span><br><span class="line">        flag1 = <span class="literal">True</span></span><br><span class="line">        flag2 = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> h1 != h2:</span><br><span class="line">            <span class="keyword">if</span> h1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> h1.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    h1 = h1.next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> flag1:</span><br><span class="line">                        h1 = headB</span><br><span class="line">                        flag1 = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        h1 = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> h2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> h2.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    h2 = h2.next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> flag2:</span><br><span class="line">                        h2 = headA</span><br><span class="line">                        flag2 = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        h2 = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> h1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第160题—相交链表&lt;/h1&gt;
&lt;p&gt;我真的菜死了QAQ，这道题写了半个多小时才写出来，一道简单题  我气哦。因为没有plus会员，我还是老实的刷免费的吧。&lt;/p&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs67
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>Python报RuntimeError NCCL Error 2 unhandled system error</title>
    <link href="www.strivezs.com/2021/08/05/Python%E6%8A%A5RuntimeError%20NCCL%20Error%202%20unhandled%20system%20error/"/>
    <id>www.strivezs.com/2021/08/05/Python%E6%8A%A5RuntimeError%20NCCL%20Error%202%20unhandled%20system%20error/</id>
    <published>2021-08-05T01:14:39.000Z</published>
    <updated>2021-08-05T01:14:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Python报RuntimeError NCCL Error 2 unhandled system error</h1><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec  -it --user root  -e NVIDIA_VISIBLE_DEVICES=<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> remote /bin/bash</span><br></pre></td></tr></table></figure><p>上面的命令，目前好像没用了。。。</p><p>github别人的方法，我通过自己创建了一个新的容器，然后在这基础上进行了配置，发现不会出现RuntimeError: NCCL Error 2: unhandled system error的问题了。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec  -it --user root --gpus all --ipc=host  -e NVIDIA_VISIBLE_DEVICES=<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> remote /bin/bash</span><br></pre></td></tr></table></figure><p>需要重新创建一个容器！！！</p><p>然后重新配置环境就好了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;Python报RuntimeError NCCL Error 2 unhandled system error&lt;/h1&gt;
&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.162</title>
    <link href="www.strivezs.com/2021/08/05/LeetCode%E7%AC%AC162%E9%A2%98/"/>
    <id>www.strivezs.com/2021/08/05/LeetCode%E7%AC%AC162%E9%A2%98/</id>
    <published>2021-08-05T01:06:06.000Z</published>
    <updated>2021-08-05T01:06:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第162题—寻找峰值</h1><p>前几天老忘了更新，我错了。QAQ<br>最新研究一下VSCode刷LeetCode好方便好舒服。</p><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>峰值元素是指其值大于左右相邻值的元素。</p><p>给你一个输入数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。</p><p>你可以假设 nums[-1] = nums[n] = -∞ 。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="number">3</span> 是峰值元素，你的函数应该返回其索引 <span class="number">2</span>。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">1</span> 或 <span class="number">5</span> </span><br><span class="line">解释：你的函数可以返回索引 <span class="number">1</span>，其峰值元素为 <span class="number">2</span>；</span><br><span class="line">     或者返回索引 <span class="number">5</span>， 其峰值元素为 <span class="number">6</span>。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">1000</span></span><br><span class="line"><span class="number">-231</span> &lt;= nums[i] &lt;= <span class="number">231</span> - <span class="number">1</span></span><br><span class="line">对于所有有效的 i 都有 nums[i] != nums[i + <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># @lc app=leetcode.cn id=162 lang=python</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># [162] 寻找峰值</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        峰值元素是指其值大于左右相邻值的元素，nums[-1] = nums[n] = -∞ </span></span><br><span class="line"><span class="string">        那么就表示只要第一个元素大于它右边的元素，就是峰值，最后一个元素大于它左边的元素，就是峰值</span></span><br><span class="line"><span class="string">        其他的遍历就好了</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = [] <span class="comment"># 结果存储</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[i+<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">                    </span><br><span class="line">            <span class="keyword">elif</span> i == len(nums)<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[i<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[i<span class="number">-1</span>] <span class="keyword">and</span> nums[i] &gt; nums[i+<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="comment"># @lc code=end</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第162题—寻找峰值&lt;/h1&gt;
&lt;p&gt;前几天老忘了更新，我错了。QAQ&lt;br&gt;
最新研究一下VSCode刷LeetCode好方便好舒服。&lt;/p&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/Le
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.155</title>
    <link href="www.strivezs.com/2021/08/02/LeetCode%E7%AC%AC155%E9%A2%98/"/>
    <id>www.strivezs.com/2021/08/02/LeetCode%E7%AC%AC155%E9%A2%98/</id>
    <published>2021-08-02T00:41:05.000Z</published>
    <updated>2021-08-02T00:41:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第155题—最小栈</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><p>push(x) —— 将元素 x 推入栈中。<br>pop() —— 删除栈顶的元素。<br>top() —— 获取栈顶元素。<br>getMin() —— 检索栈中的最小元素。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[<span class="string">"MinStack"</span>,<span class="string">"push"</span>,<span class="string">"push"</span>,<span class="string">"push"</span>,<span class="string">"getMin"</span>,<span class="string">"pop"</span>,<span class="string">"top"</span>,<span class="string">"getMin"</span>]</span><br><span class="line">[[],[-<span class="number">2</span>],[<span class="number">0</span>],[-<span class="number">3</span>],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,-<span class="number">3</span>,<span class="keyword">null</span>,<span class="number">0</span>,-<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MinStack minStack = <span class="keyword">new</span> MinStack();</span><br><span class="line">minStack.<span class="keyword">push</span>(-<span class="number">2</span>);</span><br><span class="line">minStack.<span class="keyword">push</span>(<span class="number">0</span>);</span><br><span class="line">minStack.<span class="keyword">push</span>(-<span class="number">3</span>);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -<span class="number">3</span>.</span><br><span class="line">minStack.<span class="keyword">pop</span>();</span><br><span class="line">minStack.top();      --&gt; 返回 <span class="number">0</span>.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -<span class="number">2</span>.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="keyword">pop</span>、top 和 getMin 操作总是在 非空栈 上调用</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>别问，问就是Python大法好。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack.append(val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(self.stack) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a = self.stack[<span class="number">-1</span>]</span><br><span class="line">            self.stack.pop()</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(self.stack) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a = self.stack[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> min(self.stack)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(val)</span></span><br><span class="line"><span class="comment"># obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.getMin()</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第155题—最小栈&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>链表插入排序</title>
    <link href="www.strivezs.com/2021/07/31/%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>www.strivezs.com/2021/07/31/%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</id>
    <published>2021-07-31T10:48:34.000Z</published>
    <updated>2021-07-31T10:48:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1>链表插入排序</h1><p>这里是链表的插入排序。时间效率和空间效率十分堪忧，但是思想比较简单。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, <span class="keyword">next</span>=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">next</span> = <span class="keyword">next</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertionSortList</span><span class="params">(<span class="keyword">self</span>, head)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        插入排序：除了第一个节点不动，第二个元素和前面已经排序好的元素进行比较，插入到合适的位置</span></span><br><span class="line"><span class="string">        重复上述过程即可。</span></span><br><span class="line"><span class="string">        比如:</span></span><br><span class="line"><span class="string">            1 3 5 2 4   |左边为排序好的节点</span></span><br><span class="line"><span class="string">            1 | 3 5 2 4</span></span><br><span class="line"><span class="string">            1 3 | 5 2 4</span></span><br><span class="line"><span class="string">            1 3 5 | 2 4</span></span><br><span class="line"><span class="string">            1 2 3 5 | 4</span></span><br><span class="line"><span class="string">            1 2 3 4 5 |</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> head.<span class="keyword">next</span> is <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        ends = head.<span class="keyword">next</span></span><br><span class="line">        node = head.<span class="keyword">next</span></span><br><span class="line">        start = head</span><br><span class="line">        <span class="comment"># 单独处理前两个节点</span></span><br><span class="line">        <span class="keyword">if</span> node.val &lt; start.<span class="symbol">val:</span></span><br><span class="line">            start.<span class="keyword">next</span> = node.<span class="keyword">next</span></span><br><span class="line">            node.<span class="keyword">next</span> = start</span><br><span class="line">            ends = start</span><br><span class="line">            start = node</span><br><span class="line">            head = node</span><br><span class="line">        <span class="comment"># 递归处理后面所有情况</span></span><br><span class="line">        node = ends.<span class="keyword">next</span></span><br><span class="line">        <span class="keyword">while</span> node is <span class="keyword">not</span> <span class="symbol">None:</span></span><br><span class="line">            <span class="comment"># 寻找合适的插入位置 (3种情况：头插入、中间插入、尾插入)</span></span><br><span class="line">            <span class="comment"># 头插入</span></span><br><span class="line">            <span class="keyword">if</span> node.val &lt; start.<span class="symbol">val:</span></span><br><span class="line">                ends.<span class="keyword">next</span> = node.<span class="keyword">next</span></span><br><span class="line">                node.<span class="keyword">next</span> = start</span><br><span class="line">                start = node</span><br><span class="line">                head = node</span><br><span class="line">                node = ends.<span class="keyword">next</span></span><br><span class="line">            <span class="comment"># 尾插入</span></span><br><span class="line">            elif node.val &gt; ends.<span class="symbol">val:</span></span><br><span class="line">                ends = node</span><br><span class="line">                node = ends.<span class="keyword">next</span></span><br><span class="line">            <span class="comment"># 中间插入</span></span><br><span class="line">            <span class="symbol">else:</span></span><br><span class="line">                cur = start</span><br><span class="line">                <span class="comment"># 寻找插入位置</span></span><br><span class="line">                <span class="keyword">while</span> <span class="symbol">True:</span></span><br><span class="line">                    <span class="keyword">if</span> node.val &gt;= cur.val <span class="keyword">and</span> node.val &lt;=cur.<span class="keyword">next</span>.<span class="symbol">val:</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    cur = cur.<span class="keyword">next</span></span><br><span class="line">                <span class="comment"># 插入</span></span><br><span class="line">                ends.<span class="keyword">next</span> = node.<span class="keyword">next</span></span><br><span class="line">                node.<span class="keyword">next</span> = cur.<span class="keyword">next</span></span><br><span class="line">                cur.<span class="keyword">next</span> = node</span><br><span class="line">                node = ends.<span class="keyword">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;链表插入排序&lt;/h1&gt;
&lt;p&gt;这里是链表的插入排序。时间效率和空间效率十分堪忧，但是思想比较简单。&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
    
      <category term="链表" scheme="www.strivezs.com/categories/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="算法" scheme="www.strivezs.com/categories/%E9%93%BE%E8%A1%A8/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="www.strivezs.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="www.strivezs.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="排序" scheme="www.strivezs.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="插入排序" scheme="www.strivezs.com/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>链表归并排序</title>
    <link href="www.strivezs.com/2021/07/31/%E9%93%BE%E8%A1%A8%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>www.strivezs.com/2021/07/31/%E9%93%BE%E8%A1%A8%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2021-07-31T10:48:30.000Z</published>
    <updated>2021-07-31T10:48:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1>链表归并排序</h1><p>用一张图来说明归并排序:</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/wWJB4K.jpg" alt="figure.3"></p><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, <span class="keyword">next</span>=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">next</span> = <span class="keyword">next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="comment"># fixme: 归并排序(自底向上合并链表)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(<span class="keyword">self</span>, node1, node2)</span></span><span class="symbol">:</span></span><br><span class="line">        dummy = ListNode()</span><br><span class="line">        pre = dummy</span><br><span class="line">        <span class="keyword">while</span> node1 is <span class="keyword">not</span> None <span class="keyword">and</span> node2 is <span class="keyword">not</span> <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">if</span> node1.val &lt;= node2.<span class="symbol">val:</span></span><br><span class="line">                pre.<span class="keyword">next</span> = node1</span><br><span class="line">                pre = pre.<span class="keyword">next</span></span><br><span class="line">                node1 = node1.<span class="keyword">next</span></span><br><span class="line">            <span class="symbol">else:</span></span><br><span class="line">                pre.<span class="keyword">next</span> = node2</span><br><span class="line">                pre = pre.<span class="keyword">next</span></span><br><span class="line">                node2 = node2.<span class="keyword">next</span></span><br><span class="line">        <span class="keyword">if</span> node1 is <span class="keyword">not</span> <span class="symbol">None:</span></span><br><span class="line">            pre.<span class="keyword">next</span> = node1</span><br><span class="line">        <span class="keyword">if</span> node2 is <span class="keyword">not</span> <span class="symbol">None:</span></span><br><span class="line">            pre.<span class="keyword">next</span> = node2</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="keyword">next</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># fixme: 归并排序(自顶向下划分链表)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">self</span>, head)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> head is None <span class="keyword">or</span> head.<span class="keyword">next</span> is <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 快慢指针寻找中间节点</span></span><br><span class="line">        slow = head</span><br><span class="line">        fast = head</span><br><span class="line">        <span class="keyword">while</span> fast.<span class="keyword">next</span> is <span class="keyword">not</span> None <span class="keyword">and</span> fast.<span class="keyword">next</span>.<span class="keyword">next</span> is <span class="keyword">not</span> <span class="symbol">None:</span></span><br><span class="line">            slow = slow.<span class="keyword">next</span></span><br><span class="line">            fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span></span><br><span class="line">        <span class="comment"># 找到中间节点之后断开链表</span></span><br><span class="line">        new_head = slow.<span class="keyword">next</span></span><br><span class="line">        slow.<span class="keyword">next</span> = None</span><br><span class="line">        <span class="comment"># 递归断开所有的节点</span></span><br><span class="line">        slow = <span class="keyword">self</span>.merge_sort(head)</span><br><span class="line">        fast  =<span class="keyword">self</span>.merge_sort(new_head)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 合并</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.merge(slow, fast)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(<span class="keyword">self</span>, head)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        参考大佬的题解考虑使用归并排序</span></span><br><span class="line"><span class="string">        对于数组的归并排序来说，可以直接根据数组的长度来找到中间值，对于链表来说，我们可以通过快慢指针来找到中间节点</span></span><br><span class="line"><span class="string">        然后采用递归的方法将链表层层断开，排序后</span></span><br><span class="line"><span class="string">        最后再合并</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.merge_sort(head)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;链表归并排序&lt;/h1&gt;
&lt;p&gt;用一张图来说明归并排序:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/zyp521/upload_image/raw/master/wWJB4K.jpg&quot; alt=&quot;figure.3&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码
      
    
    </summary>
    
    
      <category term="链表" scheme="www.strivezs.com/categories/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="算法" scheme="www.strivezs.com/categories/%E9%93%BE%E8%A1%A8/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="www.strivezs.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="www.strivezs.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="归并排序" scheme="www.strivezs.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="排序" scheme="www.strivezs.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.154</title>
    <link href="www.strivezs.com/2021/07/31/LeetCode%E7%AC%AC154%E9%A2%98/"/>
    <id>www.strivezs.com/2021/07/31/LeetCode%E7%AC%AC154%E9%A2%98/</id>
    <published>2021-07-31T10:44:54.000Z</published>
    <updated>2021-07-31T10:44:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第154题—寻找旋转排序数组中的最小值 II</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：</p><ul><li>若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]</li><li>若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]<br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</li></ul><p>给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">n == nums.length</span><br><span class="line"><span class="number">1</span> &lt;= n &lt;= <span class="number">5000</span></span><br><span class="line"><span class="number">-5000</span> &lt;= nums[i] &lt;= <span class="number">5000</span></span><br><span class="line">nums 原来是一个升序排序的数组，并进行了 <span class="number">1</span> 至 n 次旋转</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        除了return min(nums)之外的考虑，延续上一道题的想法</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>] &lt; nums[<span class="number">-1</span>]:</span><br><span class="line">            flag = <span class="literal">True</span>  <span class="comment"># 从左端开始找</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flag = <span class="literal">False</span>  <span class="comment"># 从右端开始找</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                <span class="keyword">if</span> nums[i] &lt; nums[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[len(nums) - i] &lt; nums[len(nums) - <span class="number">1</span> - i]:</span><br><span class="line">                    <span class="keyword">return</span> nums[len(nums) - i]</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.findMin([<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第154题—寻找旋转排序数组中的最小值 II&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.153</title>
    <link href="www.strivezs.com/2021/07/28/LeetCode%E7%AC%AC153%E9%A2%98/"/>
    <id>www.strivezs.com/2021/07/28/LeetCode%E7%AC%AC153%E9%A2%98/</id>
    <published>2021-07-28T01:08:58.000Z</published>
    <updated>2021-07-28T01:08:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第153题—寻找旋转排序数组中的最小值</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：<br>若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]<br>若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]<br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p><p>给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：原数组为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] ，旋转 <span class="number">3</span> 次得到输入数组。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：原数组为 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] ，旋转 <span class="number">4</span> 次得到输入数组。</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>]</span><br><span class="line">输出：<span class="number">11</span></span><br><span class="line">解释：原数组为 [<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>] ，旋转 <span class="number">4</span> 次得到输入数组。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">n == nums.length</span><br><span class="line"><span class="number">1</span> &lt;= n &lt;= <span class="number">5000</span></span><br><span class="line"><span class="number">-5000</span> &lt;= nums[i] &lt;= <span class="number">5000</span></span><br><span class="line">nums 中的所有整数 互不相同</span><br><span class="line">nums 原来是一个升序排序的数组，并进行了 <span class="number">1</span> 至 n 次旋转</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><h3 id="非常不推荐"><a class="header-anchor" href="#非常不推荐">¶</a>非常不推荐</h3><p>没意义.</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span>(<span class="symbol">object</span>):</span><br><span class="line">    <span class="symbol">def</span> <span class="symbol">findMin</span>(<span class="symbol">self, <span class="symbol">nums</span></span>):</span><br><span class="line">        """</span><br><span class="line">        :<span class="symbol">type</span> <span class="symbol">nums: <span class="symbol">List</span></span>[<span class="symbol">int</span>]</span><br><span class="line">        :<span class="symbol">rtype: <span class="symbol">int</span></span></span><br><span class="line">        """</span><br><span class="line">        <span class="symbol">return</span> <span class="symbol">min</span>(<span class="symbol">nums</span>)</span><br></pre></td></tr></table></figure><h3 id="正确思路"><a class="header-anchor" href="#正确思路">¶</a>正确思路</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        分析：</span></span><br><span class="line"><span class="string">            感觉题目的意思可以看出本题的实质是找到分断点(因为原数组是有序数组)</span></span><br><span class="line"><span class="string">            因此从两端开始判断的话，只需找到比较小的那一端，然后从小的那一端开始判断</span></span><br><span class="line"><span class="string">            1.如果是从左端开始的话，如果nums[i] &lt;= nums[i+1]，则继续右移，直到不满足结果</span></span><br><span class="line"><span class="string">            2. 如果是从右端开始的话，如果nums[i] &lt;= nums[i+1], 则继续左移，直到不满足结果</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>] &lt; nums[<span class="number">-1</span>]:</span><br><span class="line">            flag = <span class="literal">True</span> <span class="comment"># 从左端开始找</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flag = <span class="literal">False</span> <span class="comment"># 从右端开始找</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                <span class="keyword">if</span> nums[i] &lt; nums[i<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[len(nums) - i] &lt; nums[len(nums) - <span class="number">1</span> - i]:</span><br><span class="line">                    <span class="keyword">return</span> nums[len(nums) - i]</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.findMin(nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第153题—寻找旋转排序数组中的最小值&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和For
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.152</title>
    <link href="www.strivezs.com/2021/07/27/LeetCode%E7%AC%AC152%E9%A2%98/"/>
    <id>www.strivezs.com/2021/07/27/LeetCode%E7%AC%AC152%E9%A2%98/</id>
    <published>2021-07-27T07:38:33.000Z</published>
    <updated>2021-07-27T07:38:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第152题—乘积最大子数组</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">-2</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">6</span></span><br><span class="line">解释: 子数组 [<span class="number">2</span>,<span class="number">3</span>] 有最大乘积 <span class="number">6</span>。</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="number">-2</span>,<span class="number">0</span>,<span class="number">-1</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 结果不能为 <span class="number">2</span>, 因为 [<span class="number">-2</span>,<span class="number">-1</span>] 不是子数组。</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def maxProduct(self, nums):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        考虑使用动态规划. 因为数组中的值包含了正值和负值，可能会变为负负得正，或者你最大的正值乘个-1就会变为最小的负值</span></span><br><span class="line"><span class="string">        因此考虑使用两个数组来进行记录，分别记录当前的最大值和最小值, 然后进行后续应用</span></span><br><span class="line"><span class="string">        :type nums: List<span class="subst">[int]</span></span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        max_dp = <span class="comment">[0]</span> * len(nums)</span><br><span class="line">        min_dp = <span class="comment">[0]</span> * len(nums)</span><br><span class="line">        dp = <span class="comment">[0]</span> * len(nums)</span><br><span class="line">        max_dp<span class="comment">[0]</span> = nums<span class="comment">[0]</span></span><br><span class="line">        min_dp<span class="comment">[0]</span> = nums<span class="comment">[0]</span></span><br><span class="line">        dp<span class="comment">[0]</span> = nums<span class="comment">[0]</span></span><br><span class="line">        for i in range(1, len(nums)):</span><br><span class="line">            max_dp<span class="comment">[i]</span> = max(max_dp<span class="comment">[i-1]</span> * nums<span class="comment">[i]</span>, min_dp<span class="comment">[i-1]</span> * nums<span class="comment">[i]</span>, nums<span class="comment">[i]</span>)</span><br><span class="line">            min_dp<span class="comment">[i]</span> = min(max_dp<span class="comment">[i-1]</span> * nums<span class="comment">[i]</span>, min_dp<span class="comment">[i-1]</span> * nums<span class="comment">[i]</span>, nums<span class="comment">[i]</span>)</span><br><span class="line">            dp<span class="comment">[i]</span> = max(max_dp<span class="comment">[i]</span>, dp<span class="comment">[i-1]</span>)</span><br><span class="line">        return dp<span class="comment">[-1]</span></span><br><span class="line"></span><br><span class="line">if __name__ == '__main__':</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.maxProduct(<span class="comment">[-1, -2, -9, 6]</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第152题—乘积最大子数组&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.151</title>
    <link href="www.strivezs.com/2021/07/24/LeetCode%E7%AC%AC151%E9%A2%98/"/>
    <id>www.strivezs.com/2021/07/24/LeetCode%E7%AC%AC151%E9%A2%98/</id>
    <published>2021-07-24T01:18:47.000Z</published>
    <updated>2021-07-24T01:18:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第151题—翻转字符串里的单词</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你一个字符串 s ，逐个翻转字符串中的所有 单词 。</p><p>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。</p><p>请你返回一个翻转 s 中单词顺序并用单个空格相连的字符串。</p><p>说明：</p><ul><li>输入字符串 s 可以在前面、后面或者单词间包含多余的空格。</li><li>翻转后单词间应当仅用一个空格分隔。</li><li>翻转后的字符串中不应包含额外的空格。</li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"the sky is blue"</span></span><br><span class="line">输出：<span class="string">"blue is sky the"</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"  hello world  "</span></span><br><span class="line">输出：<span class="string">"world hello"</span></span><br><span class="line">解释：输入字符串可以在前面或者后面包含多余的空格，但是翻转后的字符不能包括。</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"a good   example"</span></span><br><span class="line">输出：<span class="string">"example good a"</span></span><br><span class="line">解释：如果两个单词间有多余的空格，将翻转后单词间的空格减少到只含一个。</span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"  Bob    Loves  Alice   "</span></span><br><span class="line">输出：<span class="string">"Alice Loves Bob"</span></span><br><span class="line">示例 <span class="number">5</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"Alice does not even like bob"</span></span><br><span class="line">输出：<span class="string">"bob like even not does Alice"</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= s.length &lt;= <span class="number">104</span></span><br><span class="line">s 包含英文大小写字母、数字和空格 ' '</span><br><span class="line">s 中 至少存在一个 单词</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">进阶：</span><br><span class="line"></span><br><span class="line">请尝试使用 O(<span class="number">1</span>) 额外空间复杂度的原地解法。</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def reverseWords(self, s):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        使用<span class="keyword">split</span>分割之后进行翻转即可</span><br><span class="line">        :<span class="built_in">type</span> <span class="variable">s:</span> str</span><br><span class="line">        :rtype: str</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        s = s.<span class="keyword">split</span>(<span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">res</span> = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[<span class="built_in">len</span>(s) - i - <span class="number">1</span>] == <span class="string">''</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">res</span> == <span class="string">''</span>:</span><br><span class="line">                <span class="keyword">res</span> = s[<span class="built_in">len</span>(s) - i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">res</span> = <span class="keyword">res</span> + <span class="string">' '</span> + s[<span class="built_in">len</span>(s) - i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">res</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="keyword">print</span>(s.reverseWords(<span class="string">"a good   example"</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第151题—翻转字符串里的单词&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 波兰式和逆波兰式</title>
    <link href="www.strivezs.com/2021/07/23/%E6%B3%A2%E5%85%B0%E5%BC%8F%E5%92%8C%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/"/>
    <id>www.strivezs.com/2021/07/23/%E6%B3%A2%E5%85%B0%E5%BC%8F%E5%92%8C%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/</id>
    <published>2021-07-23T09:20:02.000Z</published>
    <updated>2021-07-23T09:20:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1>波兰式和逆波兰式</h1><p>首先介绍一下中缀表达式，中缀表达式是人类最熟悉的表达式，比如1+2, (1+2)*3等。<br>如下图:</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/NdzPgE.jpg" alt="figure.1"></p><p>中缀表达式就是对上述二叉树进行中序遍历得到的结果。</p><p>波兰式又称为前缀表达式，它是对上述语法二叉树进行前序遍历得到的结果。上图的前缀表达式为:<br><code>-+A*B-CD*EF</code></p><p>逆波兰式又称为后缀表达式，是上述语法二叉树的后序遍历得到的结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;波兰式和逆波兰式&lt;/h1&gt;
&lt;p&gt;首先介绍一下中缀表达式，中缀表达式是人类最熟悉的表达式，比如1+2, (1+2)*3等。&lt;br&gt;
如下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/zyp521/upload_image/raw/master
      
    
    </summary>
    
    
      <category term="Math" scheme="www.strivezs.com/categories/Math/"/>
    
    
      <category term="知识点" scheme="www.strivezs.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
      <category term="Math" scheme="www.strivezs.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.150</title>
    <link href="www.strivezs.com/2021/07/23/LeetCode%E7%AC%AC150%E9%A2%98/"/>
    <id>www.strivezs.com/2021/07/23/LeetCode%E7%AC%AC150%E9%A2%98/</id>
    <published>2021-07-23T09:19:13.000Z</published>
    <updated>2021-07-23T09:19:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第150题—逆波兰表达式求值</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>根据 逆波兰表示法，求表达式的值。</p><p>有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p>说明：</p><ul><li>整数除法只保留整数部分。</li><li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li></ul><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：tokens = [<span class="string">"2"</span>,<span class="string">"1"</span>,<span class="string">"+"</span>,<span class="string">"3"</span>,<span class="string">"*"</span>]</span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：((<span class="number">2</span> + <span class="number">1</span>) * <span class="number">3</span>) = <span class="number">9</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：tokens = [<span class="string">"4"</span>,<span class="string">"13"</span>,<span class="string">"5"</span>,<span class="string">"/"</span>,<span class="string">"+"</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：(<span class="number">4</span> + (<span class="number">13</span> / <span class="number">5</span>)) = <span class="number">6</span></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：tokens = [<span class="string">"10"</span>,<span class="string">"6"</span>,<span class="string">"9"</span>,<span class="string">"3"</span>,<span class="string">"+"</span>,<span class="string">"-11"</span>,<span class="string">"*"</span>,<span class="string">"/"</span>,<span class="string">"*"</span>,<span class="string">"17"</span>,<span class="string">"+"</span>,<span class="string">"5"</span>,<span class="string">"+"</span>]</span><br><span class="line">输出：<span class="number">22</span></span><br><span class="line">解释：</span><br><span class="line">该算式转化为常见的中缀算术表达式为：</span><br><span class="line">  ((<span class="number">10</span> * (<span class="number">6</span> / ((<span class="number">9</span> + <span class="number">3</span>) * -<span class="number">11</span>))) + <span class="number">17</span>) + <span class="number">5</span></span><br><span class="line">= ((<span class="number">10</span> * (<span class="number">6</span> / (<span class="number">12</span> * -<span class="number">11</span>))) + <span class="number">17</span>) + <span class="number">5</span></span><br><span class="line">= ((<span class="number">10</span> * (<span class="number">6</span> / -<span class="number">132</span>)) + <span class="number">17</span>) + <span class="number">5</span></span><br><span class="line">= ((<span class="number">10</span> * <span class="number">0</span>) + <span class="number">17</span>) + <span class="number">5</span></span><br><span class="line">= (<span class="number">0</span> + <span class="number">17</span>) + <span class="number">5</span></span><br><span class="line">= <span class="number">17</span> + <span class="number">5</span></span><br><span class="line">= <span class="number">22</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= tokens.length &lt;= <span class="number">104</span></span><br><span class="line">tokens[i] 要么是一个算符（<span class="string">"+"</span>、<span class="string">"-"</span>、<span class="string">"*"</span> 或 <span class="string">"/"</span>），要么是一个在范围 [-<span class="number">200</span>, <span class="number">200</span>] 内的整数</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>可以说只要想到用栈和理解逆波兰式的含义就十分简单了。唯一一点就是要注意只取整数部分，不考虑小数部分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span><span class="params">(self, tokens)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        逆波兰式是后缀表达式</span></span><br><span class="line"><span class="string">        后缀表达式的求法：只需要处理符号的前两个值就可以了</span></span><br><span class="line"><span class="string">        那么就可以考虑使用栈来模拟计算过程</span></span><br><span class="line"><span class="string">        需要注意的是，这里只取整数部分，不考虑小数 因此考虑使用math.modf()</span></span><br><span class="line"><span class="string">        :type tokens: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack = [] <span class="comment"># 数字栈</span></span><br><span class="line">        characters = [<span class="string">'-'</span>, <span class="string">'+'</span>, <span class="string">'*'</span>, <span class="string">'/'</span>] <span class="comment"># 符号</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(tokens)):</span><br><span class="line">            <span class="keyword">if</span> tokens[i] <span class="keyword">in</span> characters:</span><br><span class="line">                b = stack[<span class="number">-1</span>]</span><br><span class="line">                stack.pop()</span><br><span class="line">                a = stack[<span class="number">-1</span>]</span><br><span class="line">                stack.pop()</span><br><span class="line">                <span class="keyword">if</span> tokens[i] == <span class="string">'-'</span>:</span><br><span class="line">                    c = a - b</span><br><span class="line">                <span class="keyword">elif</span> tokens[i] == <span class="string">'+'</span>:</span><br><span class="line">                    c = a + b</span><br><span class="line">                <span class="keyword">elif</span> tokens[i] == <span class="string">'*'</span>:</span><br><span class="line">                    c = a * b</span><br><span class="line">                <span class="keyword">elif</span> tokens[i] == <span class="string">'/'</span>:</span><br><span class="line">                    c = a / b</span><br><span class="line">                stack.append(math.modf(c)[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(int(tokens[i]))</span><br><span class="line">        <span class="keyword">return</span> int(stack[<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.evalRPN([<span class="string">"10"</span>,<span class="string">"6"</span>,<span class="string">"9"</span>,<span class="string">"3"</span>,<span class="string">"+"</span>,<span class="string">"-11"</span>,<span class="string">"*"</span>,<span class="string">"/"</span>,<span class="string">"*"</span>,<span class="string">"17"</span>,<span class="string">"+"</span>,<span class="string">"5"</span>,<span class="string">"+"</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第150题—逆波兰表达式求值&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.149</title>
    <link href="www.strivezs.com/2021/07/22/LeetCode%E7%AC%AC149%E9%A2%98/"/>
    <id>www.strivezs.com/2021/07/22/LeetCode%E7%AC%AC149%E9%A2%98/</id>
    <published>2021-07-22T03:26:58.000Z</published>
    <updated>2021-07-22T03:26:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第149题—直线上最多的点数</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。求最多有多少个点在同一条直线上。</p><p><img src="https://assets.leetcode.com/uploads/2021/02/25/plane1.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：points = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2021/02/25/plane2.jpg" alt="figure.2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line">输入：points = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">5</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= points.length &lt;= <span class="number">300</span></span><br><span class="line">points[i].length == <span class="number">2</span></span><br><span class="line"><span class="number">-104</span> &lt;= xi, yi &lt;= <span class="number">104</span></span><br><span class="line">points 中的所有点 互不相同</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">from fractions import Fraction</span><br><span class="line">class Solution(object):</span><br><span class="line">    # 统计在直线上点的个数</span><br><span class="line">    def num_points_on_line(self, k, b, points):</span><br><span class="line">        num = 0</span><br><span class="line">        for i in range(len(points)):</span><br><span class="line">            if points<span class="comment">[i]</span><span class="comment">[0]</span> * k + b == points<span class="comment">[i]</span><span class="comment">[1]</span>:</span><br><span class="line">                num += 1</span><br><span class="line">        return num</span><br><span class="line"></span><br><span class="line">    def time_out(self, points):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        暴力搜索的方法，目前自己能想到的方法</span></span><br><span class="line"><span class="string">        找到两个点求出斜率，然后确定还有多少个点在上面，找到最大的, 暴力搜索不出意外的Time out了，下面尝试对代码进行优化</span></span><br><span class="line"><span class="string">        :type points: List<span class="subst">[List[int]</span>]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        if len(points) == 1:</span><br><span class="line">            return 1</span><br><span class="line">        if len(points) == 2:</span><br><span class="line">            return 2</span><br><span class="line">        max_num = 0</span><br><span class="line">        for i in range(len(points)):</span><br><span class="line">            for j in range(len(points)):</span><br><span class="line">                if i == j:</span><br><span class="line">                    continue</span><br><span class="line">                if points<span class="comment">[i]</span><span class="comment">[0]</span> - points<span class="comment">[j]</span><span class="comment">[0]</span> == 0: # 为纵轴的情况</span><br><span class="line">                    cur_num = 0</span><br><span class="line">                    for m in range(len(points)):</span><br><span class="line">                        if points<span class="comment">[m]</span><span class="comment">[0]</span> == points<span class="comment">[i]</span><span class="comment">[0]</span>:</span><br><span class="line">                            cur_num += 1</span><br><span class="line">                else:</span><br><span class="line">                    k = Fraction((points<span class="comment">[i]</span><span class="comment">[1]</span> - points<span class="comment">[j]</span><span class="comment">[1]</span>) , (points<span class="comment">[i]</span><span class="comment">[0]</span> - points<span class="comment">[j]</span><span class="comment">[0]</span>))</span><br><span class="line">                    b = points<span class="comment">[i]</span><span class="comment">[1]</span> - k * points<span class="comment">[i]</span><span class="comment">[0]</span></span><br><span class="line">                    cur_num = self.num_points_on_line(k, b, points)</span><br><span class="line">                if cur_num &gt; max_num:</span><br><span class="line">                    max_num = cur_num</span><br><span class="line">        return max_num</span><br><span class="line"></span><br><span class="line">    def maxPoints(self, points):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        不出意料的暴力搜索的代码直接裂开了，我最开始的那个暴力算法冗余度太高了，后面需要进行优化，这里使用哈希表进行记忆</span></span><br><span class="line"><span class="string">        可以使用如下方法：</span></span><br><span class="line"><span class="string">            固定一个点来统计和其他的点的斜率</span></span><br><span class="line"><span class="string">            最后再将斜率和b相同的点个数统计，返回最大的值</span></span><br><span class="line"><span class="string">            考虑用字典来记录，字典：&#123;斜率: <span class="subst">[位于当前斜率上的点]</span>&#125;</span></span><br><span class="line"><span class="string">        :type points: List<span class="subst">[List[int]</span>]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        if len(points) == 1:</span><br><span class="line">            return 1</span><br><span class="line">        if len(points) == 2:</span><br><span class="line">            return 2</span><br><span class="line">        max_num = 0</span><br><span class="line">        k_num = dict()</span><br><span class="line">        for i in range(len(points)):</span><br><span class="line">            for j in range(len(points)):</span><br><span class="line">                if i == j:</span><br><span class="line">                    continue</span><br><span class="line">                if points<span class="comment">[i]</span><span class="comment">[0]</span> - points<span class="comment">[j]</span><span class="comment">[0]</span> == 0: # 为纵轴的情况  斜率不存在用对应的x值的字符串表示</span><br><span class="line">                    if str(points<span class="comment">[i]</span><span class="comment">[0]</span>) not in k_num.keys():</span><br><span class="line">                        k_num<span class="comment">[str(points<span class="comment">[i]</span><span class="comment">[0]</span>)]</span> = <span class="comment">[]</span></span><br><span class="line">                    if points<span class="comment">[i]</span> not in k_num<span class="comment">[str(points<span class="comment">[i]</span><span class="comment">[0]</span>)]</span>:</span><br><span class="line">                        k_num<span class="comment">[str(points<span class="comment">[i]</span><span class="comment">[0]</span>)]</span>.append(points<span class="comment">[i]</span>)</span><br><span class="line">                    if points<span class="comment">[j]</span> not in k_num<span class="comment">[str(points<span class="comment">[i]</span><span class="comment">[0]</span>)]</span>:</span><br><span class="line">                        k_num<span class="comment">[str(points<span class="comment">[i]</span><span class="comment">[0]</span>)]</span>.append(points<span class="comment">[j]</span>)</span><br><span class="line">                    if len(k_num<span class="comment">[str(points<span class="comment">[i]</span><span class="comment">[0]</span>)]</span>) &gt; max_num:</span><br><span class="line">                        max_num = len(k_num<span class="comment">[str(points<span class="comment">[i]</span><span class="comment">[0]</span>)]</span>)</span><br><span class="line">                else:</span><br><span class="line">                    k = Fraction((points<span class="comment">[i]</span><span class="comment">[1]</span> - points<span class="comment">[j]</span><span class="comment">[1]</span>) , (points<span class="comment">[i]</span><span class="comment">[0]</span> - points<span class="comment">[j]</span><span class="comment">[0]</span>))</span><br><span class="line">                    b = points<span class="comment">[i]</span><span class="comment">[1]</span> - k * points<span class="comment">[i]</span><span class="comment">[0]</span></span><br><span class="line">                    key = str(k)+','+str(b)</span><br><span class="line">                    if key not in k_num.keys():</span><br><span class="line">                        k_num<span class="comment">[key]</span> = <span class="comment">[]</span></span><br><span class="line">                    if points<span class="comment">[i]</span> not in k_num<span class="comment">[key]</span>:</span><br><span class="line">                        k_num<span class="comment">[key]</span>.append(points<span class="comment">[i]</span>)</span><br><span class="line">                    if points<span class="comment">[j]</span> not in k_num<span class="comment">[key]</span>:</span><br><span class="line">                        k_num<span class="comment">[key]</span>.append(points<span class="comment">[j]</span>)</span><br><span class="line">                    if len(k_num<span class="comment">[key]</span>) &gt; max_num:</span><br><span class="line">                        max_num = len(k_num<span class="comment">[key]</span>)</span><br><span class="line">        return max_num</span><br><span class="line">if __name__ == '__main__':</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.maxPoints(<span class="comment">[<span class="comment">[0,0]</span>,<span class="comment">[4,5]</span>,<span class="comment">[7,8]</span>,<span class="comment">[8,9]</span>,<span class="comment">[5,6]</span>,<span class="comment">[3,4]</span>,<span class="comment">[1,1]</span>]</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第149题—直线上最多的点数&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.148</title>
    <link href="www.strivezs.com/2021/07/21/LeetCode%E7%AC%AC148%E9%A2%98/"/>
    <id>www.strivezs.com/2021/07/21/LeetCode%E7%AC%AC148%E9%A2%98/</id>
    <published>2021-07-21T04:59:18.000Z</published>
    <updated>2021-07-21T04:59:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第148题—链表排序</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p><p>进阶：</p><p>你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" alt="figure,1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：head = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">示例 <span class="number">2</span>：</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg" alt="figure,2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">-1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>]</span><br><span class="line">输出：[<span class="number">-1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">链表中节点的数目在范围 [<span class="number">0</span>, <span class="number">5</span> * <span class="number">104</span>] 内</span><br><span class="line"><span class="number">-105</span> &lt;= Node.val &lt;= <span class="number">105</span></span><br></pre></td></tr></table></figure><h2 id="归并排序思想"><a class="header-anchor" href="#归并排序思想">¶</a>归并排序思想</h2><p>用一张图来说明归并排序:</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/wWJB4K.jpg" alt="figure.3"></p><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, <span class="keyword">next</span>=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">next</span> = <span class="keyword">next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="comment"># fixme: 归并排序(自底向上合并链表)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(<span class="keyword">self</span>, node1, node2)</span></span><span class="symbol">:</span></span><br><span class="line">        dummy = ListNode()</span><br><span class="line">        pre = dummy</span><br><span class="line">        <span class="keyword">while</span> node1 is <span class="keyword">not</span> None <span class="keyword">and</span> node2 is <span class="keyword">not</span> <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">if</span> node1.val &lt;= node2.<span class="symbol">val:</span></span><br><span class="line">                pre.<span class="keyword">next</span> = node1</span><br><span class="line">                pre = pre.<span class="keyword">next</span></span><br><span class="line">                node1 = node1.<span class="keyword">next</span></span><br><span class="line">            <span class="symbol">else:</span></span><br><span class="line">                pre.<span class="keyword">next</span> = node2</span><br><span class="line">                pre = pre.<span class="keyword">next</span></span><br><span class="line">                node2 = node2.<span class="keyword">next</span></span><br><span class="line">        <span class="keyword">if</span> node1 is <span class="keyword">not</span> <span class="symbol">None:</span></span><br><span class="line">            pre.<span class="keyword">next</span> = node1</span><br><span class="line">        <span class="keyword">if</span> node2 is <span class="keyword">not</span> <span class="symbol">None:</span></span><br><span class="line">            pre.<span class="keyword">next</span> = node2</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="keyword">next</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># fixme: 归并排序(自顶向下划分链表)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">self</span>, head)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> head is None <span class="keyword">or</span> head.<span class="keyword">next</span> is <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 快慢指针寻找中间节点</span></span><br><span class="line">        slow = head</span><br><span class="line">        fast = head</span><br><span class="line">        <span class="keyword">while</span> fast.<span class="keyword">next</span> is <span class="keyword">not</span> None <span class="keyword">and</span> fast.<span class="keyword">next</span>.<span class="keyword">next</span> is <span class="keyword">not</span> <span class="symbol">None:</span></span><br><span class="line">            slow = slow.<span class="keyword">next</span></span><br><span class="line">            fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span></span><br><span class="line">        <span class="comment"># 找到中间节点之后断开链表</span></span><br><span class="line">        new_head = slow.<span class="keyword">next</span></span><br><span class="line">        slow.<span class="keyword">next</span> = None</span><br><span class="line">        <span class="comment"># 递归断开所有的节点</span></span><br><span class="line">        slow = <span class="keyword">self</span>.merge_sort(head)</span><br><span class="line">        fast  =<span class="keyword">self</span>.merge_sort(new_head)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 合并</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.merge(slow, fast)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(<span class="keyword">self</span>, head)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        参考大佬的题解考虑使用归并排序</span></span><br><span class="line"><span class="string">        对于数组的归并排序来说，可以直接根据数组的长度来找到中间值，对于链表来说，我们可以通过快慢指针来找到中间节点</span></span><br><span class="line"><span class="string">        然后采用递归的方法将链表层层断开，排序后</span></span><br><span class="line"><span class="string">        最后再合并</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.merge_sort(head)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第148题—链表排序&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.147</title>
    <link href="www.strivezs.com/2021/07/20/LeetCode%E7%AC%AC147%E9%A2%98/"/>
    <id>www.strivezs.com/2021/07/20/LeetCode%E7%AC%AC147%E9%A2%98/</id>
    <published>2021-07-20T02:17:16.000Z</published>
    <updated>2021-07-20T02:17:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第147题—对链表进行插入排序</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>对链表进行插入排序。</p><p>插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。<br>每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。</p><p>插入排序算法：</p><p>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。<br>每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。<br>重复直到所有输入数据插入完为止。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入: <span class="number">4</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">3</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入: <span class="number">-1</span>-&gt;<span class="number">5</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">0</span></span><br><span class="line">输出: <span class="number">-1</span>-&gt;<span class="number">0</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="插入排序原理"><a class="header-anchor" href="#插入排序原理">¶</a>插入排序原理</h2><p>用一张原理图来说明。</p><p><img src="https://pic.leetcode-cn.com/1617881719-yBaKKi-Insertion-sort-example-300px.gif" alt="figure.1"></p><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, <span class="keyword">next</span>=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">next</span> = <span class="keyword">next</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertionSortList</span><span class="params">(<span class="keyword">self</span>, head)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        插入排序：除了第一个节点不动，第二个元素和前面已经排序好的元素进行比较，插入到合适的位置</span></span><br><span class="line"><span class="string">        重复上述过程即可。</span></span><br><span class="line"><span class="string">        比如:</span></span><br><span class="line"><span class="string">            1 3 5 2 4   |左边为排序好的节点</span></span><br><span class="line"><span class="string">            1 | 3 5 2 4</span></span><br><span class="line"><span class="string">            1 3 | 5 2 4</span></span><br><span class="line"><span class="string">            1 3 5 | 2 4</span></span><br><span class="line"><span class="string">            1 2 3 5 | 4</span></span><br><span class="line"><span class="string">            1 2 3 4 5 |</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> head.<span class="keyword">next</span> is <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        ends = head.<span class="keyword">next</span></span><br><span class="line">        node = head.<span class="keyword">next</span></span><br><span class="line">        start = head</span><br><span class="line">        <span class="comment"># 单独处理前两个节点</span></span><br><span class="line">        <span class="keyword">if</span> node.val &lt; start.<span class="symbol">val:</span></span><br><span class="line">            start.<span class="keyword">next</span> = node.<span class="keyword">next</span></span><br><span class="line">            node.<span class="keyword">next</span> = start</span><br><span class="line">            ends = start</span><br><span class="line">            start = node</span><br><span class="line">            head = node</span><br><span class="line">        <span class="comment"># 递归处理后面所有情况</span></span><br><span class="line">        node = ends.<span class="keyword">next</span></span><br><span class="line">        <span class="keyword">while</span> node is <span class="keyword">not</span> <span class="symbol">None:</span></span><br><span class="line">            <span class="comment"># 寻找合适的插入位置 (3种情况：头插入、中间插入、尾插入)</span></span><br><span class="line">            <span class="comment"># 头插入</span></span><br><span class="line">            <span class="keyword">if</span> node.val &lt; start.<span class="symbol">val:</span></span><br><span class="line">                ends.<span class="keyword">next</span> = node.<span class="keyword">next</span></span><br><span class="line">                node.<span class="keyword">next</span> = start</span><br><span class="line">                start = node</span><br><span class="line">                head = node</span><br><span class="line">                node = ends.<span class="keyword">next</span></span><br><span class="line">            <span class="comment"># 尾插入</span></span><br><span class="line">            elif node.val &gt; ends.<span class="symbol">val:</span></span><br><span class="line">                ends = node</span><br><span class="line">                node = ends.<span class="keyword">next</span></span><br><span class="line">            <span class="comment"># 中间插入</span></span><br><span class="line">            <span class="symbol">else:</span></span><br><span class="line">                cur = start</span><br><span class="line">                <span class="comment"># 寻找插入位置</span></span><br><span class="line">                <span class="keyword">while</span> <span class="symbol">True:</span></span><br><span class="line">                    <span class="keyword">if</span> node.val &gt;= cur.val <span class="keyword">and</span> node.val &lt;=cur.<span class="keyword">next</span>.<span class="symbol">val:</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    cur = cur.<span class="keyword">next</span></span><br><span class="line">                <span class="comment"># 插入</span></span><br><span class="line">                ends.<span class="keyword">next</span> = node.<span class="keyword">next</span></span><br><span class="line">                node.<span class="keyword">next</span> = cur.<span class="keyword">next</span></span><br><span class="line">                cur.<span class="keyword">next</span> = node</span><br><span class="line">                node = ends.<span class="keyword">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第147题—对链表进行插入排序&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.146</title>
    <link href="www.strivezs.com/2021/07/19/LeetCode%E7%AC%AC146%E9%A2%98/"/>
    <id>www.strivezs.com/2021/07/19/LeetCode%E7%AC%AC146%E9%A2%98/</id>
    <published>2021-07-19T03:10:07.000Z</published>
    <updated>2021-07-19T03:10:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第146题—LRU缓存机制</h1><p>回家休息几天，搬宿舍心累。再回实验室就开始好好科研了！！！</p><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。<br>实现 LRUCache 类：</p><p>LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p><p>进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">[<span class="string">"LRUCache"</span>, <span class="string">"put"</span>, <span class="string">"put"</span>, <span class="string">"get"</span>, <span class="string">"put"</span>, <span class="string">"get"</span>, <span class="string">"put"</span>, <span class="string">"get"</span>, <span class="string">"get"</span>, <span class="string">"get"</span>]</span><br><span class="line">[[<span class="number">2</span>], [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">1</span>], [<span class="number">3</span>, <span class="number">3</span>], [<span class="number">2</span>], [<span class="number">4</span>, <span class="number">4</span>], [<span class="number">1</span>], [<span class="number">3</span>], [<span class="number">4</span>]]</span><br><span class="line">输出</span><br><span class="line">[<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">1</span>, <span class="literal">null</span>, <span class="number">-1</span>, <span class="literal">null</span>, <span class="number">-1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache = new LRUCache(<span class="number">2</span>);</span><br><span class="line">lRUCache.put(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 缓存是 &#123;1=1&#125;</span></span><br><span class="line">lRUCache.put(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 缓存是 &#123;1=1, 2=2&#125;</span></span><br><span class="line">lRUCache.<span class="keyword">get</span>(<span class="number">1</span>);    <span class="comment">// 返回 1</span></span><br><span class="line">lRUCache.put(<span class="number">3</span>, <span class="number">3</span>); <span class="comment">// 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span></span><br><span class="line">lRUCache.<span class="keyword">get</span>(<span class="number">2</span>);    <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">lRUCache.put(<span class="number">4</span>, <span class="number">4</span>); <span class="comment">// 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span></span><br><span class="line">lRUCache.<span class="keyword">get</span>(<span class="number">1</span>);    <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">lRUCache.<span class="keyword">get</span>(<span class="number">3</span>);    <span class="comment">// 返回 3</span></span><br><span class="line">lRUCache.<span class="keyword">get</span>(<span class="number">4</span>);    <span class="comment">// 返回 4</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= capacity &lt;= <span class="number">3000</span></span><br><span class="line"><span class="number">0</span> &lt;= key &lt;= <span class="number">10000</span></span><br><span class="line"><span class="number">0</span> &lt;= value &lt;= <span class="number">105</span></span><br><span class="line">最多调用 <span class="number">2</span> * <span class="number">105</span> 次 <span class="keyword">get</span> 和 put</span><br></pre></td></tr></table></figure><h2 id="LRU缓存机制介绍"><a class="header-anchor" href="#LRU缓存机制介绍">¶</a>LRU缓存机制介绍</h2><p>LRU：最近最少使用缓存机制</p><p>其设计的原则依据：如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。<br>假定系统为某进程分配了3个物理块，进程运行时的页面走向为 7 0 1 2 0 3 0 4，开始时3个物理块均为空，那么LRU算法是如下工作的：</p><p><img src="https://img-blog.csdnimg.cn/20191102105842382.png" alt="figure.1"></p><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><h3 id="自己写的"><a class="header-anchor" href="#自己写的">¶</a>自己写的</h3><p>效率和内存差了点，但是自己纯手工写的。QAQ<br>核心思想就是通过使用双向链表和字典来存储内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    LRU 最近最少使用缓存机制：</span></span><br><span class="line"><span class="string">    ["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]</span></span><br><span class="line"><span class="string">    [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span></span><br><span class="line"><span class="string">    对上面例子分析:</span></span><br><span class="line"><span class="string">        1. LRUCache 2 表示：创建一个容量为2的LRU缓存</span></span><br><span class="line"><span class="string">        2. put表示执行put操作，把1放到LRU中，并设置它的使用次数为1 其他所有数值的使用次数-1</span></span><br><span class="line"><span class="string">        3. put 2，2表示：把2放到LRU中，并设置它的使用次数为1 其他所有数值的使用次数-1</span></span><br><span class="line"><span class="string">        4. get 1表示使用一次LRU中的1，并将它的使用次数+1  其他所有数值的使用次数-1</span></span><br><span class="line"><span class="string">        5. put 3，3表示：把3放入到LRU中，因为LRU已经满了，因此需要将使用次数最小的那个值(2)置换出来，把3放进入 其他所有数值的使用次数-1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    使用字典来存储key-value</span></span><br><span class="line"><span class="string">    使用list作为双端链表来存储使用次数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type capacity: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.length = capacity</span><br><span class="line">        self.lru_cache = [] <span class="comment"># 双端链表，头部表示最新使用的节点，尾部是最久没使用的节点</span></span><br><span class="line">        self.key_value = dict()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.key_value.keys():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果能够获取，将访问的node放置于链表最前头</span></span><br><span class="line">            self.lru_cache.remove(key)</span><br><span class="line">            self.lru_cache.insert(<span class="number">0</span>,key) <span class="comment"># 置于链表头部</span></span><br><span class="line">            <span class="keyword">return</span> self.key_value[key]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :type value: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.key_value.keys():</span><br><span class="line">            self.key_value[key] = value  <span class="comment"># 更新</span></span><br><span class="line">            <span class="comment"># 如果能够获取，将访问的node放置于链表最前头</span></span><br><span class="line">            self.lru_cache.remove(key)</span><br><span class="line">            self.lru_cache.insert(<span class="number">0</span>, key)  <span class="comment"># 置于链表头部</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> len(self.key_value) &lt; self.length:</span><br><span class="line">                self.lru_cache.insert(<span class="number">0</span>, key)  <span class="comment"># 置于链表头部</span></span><br><span class="line">                self.key_value[key] = value</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 链表末尾元素出链表</span></span><br><span class="line">                rm_key = self.lru_cache[<span class="number">-1</span>]</span><br><span class="line">                self.lru_cache.pop()</span><br><span class="line">                self.key_value.pop(rm_key)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 添加新的元素</span></span><br><span class="line">                self.lru_cache.insert(<span class="number">0</span>, key)  <span class="comment"># 置于链表头部</span></span><br><span class="line">                self.key_value[key] = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t1 = [<span class="string">"LRUCache"</span>,<span class="string">"get"</span>,<span class="string">"put"</span>,<span class="string">"get"</span>,<span class="string">"put"</span>,<span class="string">"put"</span>,<span class="string">"get"</span>,<span class="string">"get"</span>]</span><br><span class="line"></span><br><span class="line">    t2 = [[<span class="number">2</span>],[<span class="number">2</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">1</span>],[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>],[<span class="number">2</span>]]</span><br><span class="line">    t = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(t1)):</span><br><span class="line">        <span class="keyword">if</span> t1[i] == <span class="string">'LRUCache'</span>:</span><br><span class="line">            t = LRUCache(t2[i][<span class="number">0</span>])</span><br><span class="line">            print(<span class="string">'None'</span>)</span><br><span class="line">        <span class="keyword">elif</span> t1[i] == <span class="string">'put'</span>:</span><br><span class="line">            print(t.put(t2[i][<span class="number">0</span>], t2[i][<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">elif</span> t1[i] == <span class="string">'get'</span>:</span><br><span class="line">            print(t.get(t2[i][<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第146题—LRU缓存机制&lt;/h1&gt;
&lt;p&gt;回家休息几天，搬宿舍心累。再回实验室就开始好好科研了！！！&lt;/p&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Rec
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
</feed>
