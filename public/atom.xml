<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>StriveZs的博客</title>
  
  <subtitle>Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.strivezs.com/"/>
  <updated>2021-06-30T03:33:05.924Z</updated>
  <id>www.strivezs.com/</id>
  
  <author>
    <name>StriveZs</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>给服务器上的Jupyter Lab安装Kite进行自动代码补全设置</title>
    <link href="www.strivezs.com/2021/06/30/%E7%BB%99%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84Jupyter%20Lab%E5%AE%89%E8%A3%85Kite%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8%E8%AE%BE%E7%BD%AE/"/>
    <id>www.strivezs.com/2021/06/30/%E7%BB%99%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84Jupyter%20Lab%E5%AE%89%E8%A3%85Kite%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8%E8%AE%BE%E7%BD%AE/</id>
    <published>2021-06-30T03:33:05.924Z</published>
    <updated>2021-06-30T03:33:05.924Z</updated>
    
    <content type="html"><![CDATA[<h1>给服务器上的Jupyter Lab安装Kite进行自动代码补全设置</h1><h2 id="安装Jupyter-Lab"><a class="header-anchor" href="#安装Jupyter-Lab">¶</a>安装Jupyter Lab</h2><p>使用如下命令安装Jupyter Lab:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="keyword">install</span> juputerlab</span><br></pre></td></tr></table></figure><h2 id="安装Kite"><a class="header-anchor" href="#安装Kite">¶</a>安装Kite</h2><p>这里我是在docker中安装的kite，需要下载kite的安装包，又因为docker容器内没有wget，因此现需要安装wget，使用如下命令:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install wget</span><br></pre></td></tr></table></figure><p>安装完成wget之后使用如下命令安装kite：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bash </span>-c <span class="string">"$(wget -q -O - https://linux.kite.com/dls/linux/current)"</span></span><br></pre></td></tr></table></figure><p>想要关闭的时候直接在 htop 面板中找到 pid 然后将进程 kill 掉即可。</p><h2 id="设置Kite开机自启"><a class="header-anchor" href="#设置Kite开机自启">¶</a>设置Kite开机自启</h2><p>根据给的提示可以看出需要使用命令进行如下操作:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[installer] kite <span class="keyword">is</span> installed! launching now! happy coding! :)</span><br><span class="line">[installer] <span class="keyword">with</span> systemd, <span class="built_in">run</span> systemctl <span class="comment">--user start kite-autostart</span></span><br><span class="line">[installer] <span class="keyword">without</span> systemd, <span class="built_in">run</span> /home/user/.<span class="keyword">local</span>/share/kite/kited</span><br><span class="line">[installer] <span class="keyword">or</span> <span class="built_in">launch</span> <span class="keyword">it</span> using <span class="keyword">the</span> Applications Menu</span><br><span class="line">Removing kite-installer</span><br></pre></td></tr></table></figure><p>由于我是在docker中运行的，没有systemd命令，因此需要先使用如下命令安装systemd:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install --reinstall systemd</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> install systemd</span><br></pre></td></tr></table></figure><p>安装完成之后，使用如下命令设置kite自动运行:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl --<span class="keyword">user</span> <span class="title">start</span> kite-autostart</span><br></pre></td></tr></table></figure><h3 id="手动开启-每次启动docker都要打开"><a class="header-anchor" href="#手动开启-每次启动docker都要打开">¶</a>手动开启 每次启动docker都要打开</h3><p>如果没有安装systemctl成功的话，可以使用手动的方式进行启动, 命令如下:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/home/u</span>ser<span class="regexp">/.local/</span>share<span class="regexp">/kite/</span>kited</span><br></pre></td></tr></table></figure><h2 id="为Jupyter-Lab安装Kite扩展"><a class="header-anchor" href="#为Jupyter-Lab安装Kite扩展">¶</a>为Jupyter Lab安装Kite扩展</h2><p>对于 3.0 版本以上的 JupyterLab，运行如下命令:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> <span class="string">"jupyterlab-kite&gt;=2.0.2"</span></span><br></pre></td></tr></table></figure><p>亲测conda install安装失败了不知道为啥。</p><p>完成以上两步以后重启 JupyterLab，会自动弹出一个 Kite 的教程。</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/OSNQAf.png" alt="figure.1"></p><p>等待kite ready即可</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/JNV0ls.png" alt="figure.2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;给服务器上的Jupyter Lab安装Kite进行自动代码补全设置&lt;/h1&gt;
&lt;h2 id=&quot;安装Jupyter-Lab&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#安装Jupyter-Lab&quot;&gt;¶&lt;/a&gt;安装Jupyter Lab&lt;/h2&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="www.strivezs.com/categories/Linux/"/>
    
      <category term="Jupyter" scheme="www.strivezs.com/categories/Linux/Jupyter/"/>
    
      <category term="服务器" scheme="www.strivezs.com/categories/Linux/Jupyter/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Python" scheme="www.strivezs.com/tags/Python/"/>
    
      <category term="Linux" scheme="www.strivezs.com/tags/Linux/"/>
    
      <category term="服务器" scheme="www.strivezs.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Jupyter" scheme="www.strivezs.com/tags/Jupyter/"/>
    
      <category term="Kite" scheme="www.strivezs.com/tags/Kite/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.134</title>
    <link href="www.strivezs.com/2021/06/30/LeetCode%E7%AC%AC134%E9%A2%98/"/>
    <id>www.strivezs.com/2021/06/30/LeetCode%E7%AC%AC134%E9%A2%98/</id>
    <published>2021-06-30T03:26:44.400Z</published>
    <updated>2021-06-30T03:26:44.400Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第134题—加油站</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p>说明:</p><ul><li>如果题目有解，该答案即为唯一答案。</li><li>输入数组均为非空数组，且长度相同。</li><li>输入数组中的元素均为非负数。</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">gas  = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">cost = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">从 <span class="number">3</span> 号加油站(索引为 <span class="number">3</span> 处)出发，可获得 <span class="number">4</span> 升汽油。此时油箱有 = <span class="number">0</span> + <span class="number">4</span> = <span class="number">4</span> 升汽油</span><br><span class="line">开往 <span class="number">4</span> 号加油站，此时油箱有 <span class="number">4</span> - <span class="number">1</span> + <span class="number">5</span> = <span class="number">8</span> 升汽油</span><br><span class="line">开往 <span class="number">0</span> 号加油站，此时油箱有 <span class="number">8</span> - <span class="number">2</span> + <span class="number">1</span> = <span class="number">7</span> 升汽油</span><br><span class="line">开往 <span class="number">1</span> 号加油站，此时油箱有 <span class="number">7</span> - <span class="number">3</span> + <span class="number">2</span> = <span class="number">6</span> 升汽油</span><br><span class="line">开往 <span class="number">2</span> 号加油站，此时油箱有 <span class="number">6</span> - <span class="number">4</span> + <span class="number">3</span> = <span class="number">5</span> 升汽油</span><br><span class="line">开往 <span class="number">3</span> 号加油站，你需要消耗 <span class="number">5</span> 升汽油，正好足够你返回到 <span class="number">3</span> 号加油站。</span><br><span class="line">因此，<span class="number">3</span> 可为起始索引。</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">gas  = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">cost = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">你不能从 <span class="number">0</span> 号或 <span class="number">1</span> 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">我们从 <span class="number">2</span> 号加油站出发，可以获得 <span class="number">4</span> 升汽油。 此时油箱有 = <span class="number">0</span> + <span class="number">4</span> = <span class="number">4</span> 升汽油</span><br><span class="line">开往 <span class="number">0</span> 号加油站，此时油箱有 <span class="number">4</span> - <span class="number">3</span> + <span class="number">2</span> = <span class="number">3</span> 升汽油</span><br><span class="line">开往 <span class="number">1</span> 号加油站，此时油箱有 <span class="number">3</span> - <span class="number">3</span> + <span class="number">3</span> = <span class="number">3</span> 升汽油</span><br><span class="line">你无法返回 <span class="number">2</span> 号加油站，因为返程需要消耗 <span class="number">4</span> 升汽油，但是你的油箱只有 <span class="number">3</span> 升汽油。</span><br><span class="line">因此，无论怎样，你都不可能绕环路行驶一周。</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas, cost)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        分析：</span></span><br><span class="line"><span class="string">            第i个加油站有gas[i]升汽油，从第i个加油站开往第i+1个加油站需要消耗汽油cost[i]升，从这里可以看出，行驶方向只能正序0-&gt;1-&gt;2这种</span></span><br><span class="line"><span class="string">            油箱容量无限，从其中一个加油站出发，初始油箱为空</span></span><br><span class="line"><span class="string">            目标：绕环路一圈，则返回出发加油站编号，否则返回-1  (如果有解则解唯一)</span></span><br><span class="line"><span class="string">        思路:</span></span><br><span class="line"><span class="string">            1. 用gas对应位去减去cost得到一个subtraction</span></span><br><span class="line"><span class="string">            2. subtraction的总和大于等于0的话，则一定是有解的</span></span><br><span class="line"><span class="string">            3. 如果有解的话，subtraction为负值的地方，则表示不能作为初始的位置, 所有非负的地方都可以作为候选起始位置，这个时候要要根据subtraction来判断那个位置作为初始位置(唯一)</span></span><br><span class="line"><span class="string">            4. 依次判断上面非负位置</span></span><br><span class="line"><span class="string">            5. 可能会出现几种结束条件</span></span><br><span class="line"><span class="string">              i) i=0 j=4 总和满足大于等于0的合法情况</span></span><br><span class="line"><span class="string">              ii) i=3 j=2 总和满足大于等于0的合法情况</span></span><br><span class="line"><span class="string">              iii) 总和小于0的非法情况</span></span><br><span class="line"><span class="string">        :type gas: List[int]</span></span><br><span class="line"><span class="string">        :type cost: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        subtraction = list(map(<span class="keyword">lambda</span> x:x[<span class="number">0</span>]-x[<span class="number">1</span>],zip(gas,cost))) <span class="comment"># 进行数组对应位相减</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(subtraction)):</span><br><span class="line">            <span class="keyword">if</span> subtraction[i] &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            j = i</span><br><span class="line">            curSum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                curSum += subtraction[j]</span><br><span class="line">                <span class="comment"># i=4 j=3这种情况的结束条件</span></span><br><span class="line">                <span class="keyword">if</span> j == i<span class="number">-1</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># j=4 i=0这种情况的结束条件</span></span><br><span class="line">                <span class="keyword">if</span> j - i + <span class="number">1</span> == len(subtraction):</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> curSum &lt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> j &lt; len(subtraction)<span class="number">-1</span>:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    j = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 符合的判决条件</span></span><br><span class="line">            <span class="keyword">if</span> (j == i<span class="number">-1</span> <span class="keyword">or</span> j - i + <span class="number">1</span> == len(subtraction)) <span class="keyword">and</span> curSum &gt;=<span class="number">0</span> :</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.canCompleteCircuit([<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第134题—加油站&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.133</title>
    <link href="www.strivezs.com/2021/06/16/LeetCode%E7%AC%AC133%E9%A2%98/"/>
    <id>www.strivezs.com/2021/06/16/LeetCode%E7%AC%AC133%E9%A2%98/</id>
    <published>2021-06-16T11:53:17.361Z</published>
    <updated>2021-06-16T11:53:17.361Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第133题—克隆图</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。</p><p>图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。</p><p>class Node {<br>public int val;<br>public List<Node> neighbors;<br>}</p><p>测试用例格式：</p><p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。</p><p>邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p><p>给定节点将始终是图中的第一个节点（值为 1）。你必须将 给定节点的拷贝 作为对克隆图的引用返回。</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/8GP8e1.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：adjList = [[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line">输出：[[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line">解释：</span><br><span class="line">图中有 <span class="number">4</span> 个节点。</span><br><span class="line">节点 <span class="number">1</span> 的值是 <span class="number">1</span>，它有两个邻居：节点 <span class="number">2</span> 和 <span class="number">4</span> 。</span><br><span class="line">节点 <span class="number">2</span> 的值是 <span class="number">2</span>，它有两个邻居：节点 <span class="number">1</span> 和 <span class="number">3</span> 。</span><br><span class="line">节点 <span class="number">3</span> 的值是 <span class="number">3</span>，它有两个邻居：节点 <span class="number">2</span> 和 <span class="number">4</span> 。</span><br><span class="line">节点 <span class="number">4</span> 的值是 <span class="number">4</span>，它有两个邻居：节点 <span class="number">1</span> 和 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zyp521/upload_image/raw/master/u922LX.jpg" alt="figure.2"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：adjList = <span class="string">[[]]</span></span><br><span class="line">输出：<span class="string">[[]]</span></span><br><span class="line">解释：输入包含一个空列表。该图仅仅只有一个值为 <span class="number">1</span> 的节点，它没有任何邻居。</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：adjList = []</span><br><span class="line">输出：[]</span><br><span class="line">解释：这个图是空的，它不含任何节点。</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zyp521/upload_image/raw/master/iaX0Mu.jpg" alt="figure.3"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：adjList = <span class="string">[[2],[1]]</span></span><br><span class="line">输出：<span class="string">[[2],[1]]</span></span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">节点数不超过 <span class="number">100</span> 。</span><br><span class="line">每个节点值 Node.val 都是唯一的，<span class="number">1</span> &lt;= Node.val &lt;= <span class="number">100</span>。</span><br><span class="line">无向图是一个简单图，这意味着图中没有重复的边，也没有自环。</span><br><span class="line">由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。</span><br><span class="line">图是连通图，你可以从给定节点访问到所有节点。</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p>好奇挖，自己写的命名逻辑一点问题都没有，硬是不接受！！！</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a Node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val = <span class="number">0</span>, neighbors = None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.neighbors = neighbors <span class="keyword">if</span> neighbors is <span class="keyword">not</span> None <span class="keyword">else</span> []</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    node_neighbors_relation_dict = dict()</span><br><span class="line">    val_node = dict()</span><br><span class="line">    <span class="comment"># fixme:DFS建图</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(<span class="keyword">self</span>, node)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> node.val <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">self</span>.node_neighbors_relation_dict.keys()<span class="symbol">:</span></span><br><span class="line">            <span class="keyword">if</span> node.val <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">self</span>.val_node.keys()<span class="symbol">:</span></span><br><span class="line">                <span class="keyword">self</span>.val_node[node.val] = Node(node.val)</span><br><span class="line">            <span class="keyword">self</span>.node_neighbors_relation_dict[node.val] = []</span><br><span class="line">            <span class="keyword">if</span> len(node.neighbors) != <span class="number">0</span><span class="symbol">:</span></span><br><span class="line">                <span class="keyword">for</span> item <span class="keyword">in</span> node.<span class="symbol">neighbors:</span></span><br><span class="line">                    <span class="keyword">self</span>.node_neighbors_relation_dict[node.val].append(item.val)</span><br><span class="line">                    <span class="keyword">self</span>.dfs(item)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(<span class="keyword">self</span>, node)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type node: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        几个前提条件:</span></span><br><span class="line"><span class="string">            1. 每个节点值 Node.val 都是唯一的，利用这一点就可以建立一个访问过节点的列表，保证不会再次被访问</span></span><br><span class="line"><span class="string">            2. 图是连通图，你可以从给定节点访问到所有节点</span></span><br><span class="line"><span class="string">            3. 由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居</span></span><br><span class="line"><span class="string">        然后采用深度DFS形成邻居关系字典，其实这里考虑使用邻接矩阵或者邻接表也可以</span></span><br><span class="line"><span class="string">        然后最后再利用字典关系进行建图</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">self</span>.node_neighbors_relation_dict = dict()</span><br><span class="line">        <span class="keyword">self</span>.val_node = dict()</span><br><span class="line">        <span class="keyword">if</span> node == <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">return</span> None</span><br><span class="line">        <span class="keyword">self</span>.dfs(node)</span><br><span class="line">        <span class="comment"># 利用构建的节点邻居关系字典来建图</span></span><br><span class="line">        res = None</span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> <span class="keyword">self</span>.node_neighbors_relation_dict.keys()<span class="symbol">:</span></span><br><span class="line">            temp = Node(item)</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">1</span><span class="symbol">:</span></span><br><span class="line">                res = temp</span><br><span class="line">                num +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> iNode <span class="keyword">in</span> <span class="keyword">self</span>.node_neighbors_relation_dict[item]<span class="symbol">:</span></span><br><span class="line">                temp.neighbors.append(<span class="keyword">self</span>.val_node[iNode])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    res = dict()</span><br><span class="line">    <span class="comment"># fixme:上一个版本出问题了，下面是修正版本，虽然没找出来什么问题</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DFS_NV</span><span class="params">(<span class="keyword">self</span>, node)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.res[node] = Node(node.val) <span class="comment"># 新建节点</span></span><br><span class="line">        <span class="keyword">for</span> iNode <span class="keyword">in</span> node.<span class="symbol">neighbors:</span></span><br><span class="line">            <span class="keyword">if</span> iNode <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">self</span>.res.keys()<span class="symbol">:</span></span><br><span class="line">                <span class="keyword">self</span>.res[node].neighbors = [<span class="keyword">self</span>.DFS_NV(iNode)]</span><br><span class="line">            <span class="symbol">else:</span></span><br><span class="line">                <span class="keyword">self</span>.res[node].neighbors = [<span class="keyword">self</span>.res[iNode]]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.res[node]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cloneGraph</span><span class="params">(<span class="keyword">self</span>, node)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type node: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        几个前提条件:</span></span><br><span class="line"><span class="string">            1. 每个节点值 Node.val 都是唯一的，利用这一点就可以建立一个访问过节点的列表，保证不会再次被访问</span></span><br><span class="line"><span class="string">            2. 图是连通图，你可以从给定节点访问到所有节点</span></span><br><span class="line"><span class="string">            3. 由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居</span></span><br><span class="line"><span class="string">        然后采用深度DFS形成邻居关系字典，其实这里考虑使用邻接矩阵或者邻接表也可以</span></span><br><span class="line"><span class="string">        然后最后再利用字典关系进行建图</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        <span class="keyword">self</span>.res = dict()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.DFS_NV(node)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">'__main__'</span><span class="symbol">:</span></span><br><span class="line">    node1 = Node(<span class="number">1</span>)</span><br><span class="line">    node2 = Node(<span class="number">2</span>)</span><br><span class="line">    node3 = Node(<span class="number">3</span>)</span><br><span class="line">    node4 = Node(<span class="number">4</span>)</span><br><span class="line">    node1.neighbors.append(node2)</span><br><span class="line">    node1.neighbors.append(node4)</span><br><span class="line">    node2.neighbors.append(node1)</span><br><span class="line">    node2.neighbors.append(node3)</span><br><span class="line">    node3.neighbors.append(node2)</span><br><span class="line">    node3.neighbors.append(node4)</span><br><span class="line">    node4.neighbors.append(node1)</span><br><span class="line">    node4.neighbors.append(node3)</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.cloneGraph(node1).val)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第133题—克隆图&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.132</title>
    <link href="www.strivezs.com/2021/06/14/LeetCode%E7%AC%AC132%E9%A2%98/"/>
    <id>www.strivezs.com/2021/06/14/LeetCode%E7%AC%AC132%E9%A2%98/</id>
    <published>2021-06-14T14:35:37.191Z</published>
    <updated>2021-06-14T14:35:37.191Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第132题—分隔回文串II</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文。</p><p>返回符合要求的 最少分割次数 。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"aab"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：只需一次分割就可将 s 分割成 [<span class="string">"aa"</span>,<span class="string">"b"</span>] 这样两个回文子串。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"a"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"ab"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= s.length &lt;= <span class="number">2000</span></span><br><span class="line">s 仅由小写英文字母组成</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># fixme:判断是否是回文串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> s == s[::<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># fixme:回溯法超时版本</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">time_out</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        最终的结果，每个字符单独拿出来肯定是一个回文串, 因此不存在空字符串结果的情况，除非输入就是空串</span></span><br><span class="line"><span class="string">        算法考虑的话，有两种方法:</span></span><br><span class="line"><span class="string">            1. 动态规划</span></span><br><span class="line"><span class="string">            2. 回溯法</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 回溯法</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(s, res, path)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">                res.append(len(path))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s) + <span class="number">1</span>):  <span class="comment"># 注意起始和结束位置</span></span><br><span class="line">                <span class="keyword">if</span> self.isPalindrome(s[:i]):</span><br><span class="line">                    backtrack(s[i:], res, path + [s[:i]])</span><br><span class="line">        backtrack(s,res,[])</span><br><span class="line">        <span class="keyword">return</span> min(res)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># fixme:动态规划版本</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCut</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        dp = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s))] <span class="comment"># 创建dp数组  0-len(s)-1 最少划分0次最多都划分完</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>):</span><br><span class="line">                temp = s[j:i+<span class="number">1</span>]</span><br><span class="line">                <span class="comment"># 如果是回文串</span></span><br><span class="line">                <span class="keyword">if</span> temp == temp[::<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                        dp[i] = min(dp[i], dp[j - <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> dp[len(s) - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第132题—分隔回文串II&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.131</title>
    <link href="www.strivezs.com/2021/06/13/LeetCode%E7%AC%AC131%E9%A2%98/"/>
    <id>www.strivezs.com/2021/06/13/LeetCode%E7%AC%AC131%E9%A2%98/</id>
    <published>2021-06-13T03:52:35.085Z</published>
    <updated>2021-06-13T03:52:35.085Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第131题—分隔回文串</h1><p>昨天端午鸽了塞</p><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。</p><p>回文串 是正着读和反着读都一样的字符串。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"aab"</span></span><br><span class="line">输出：[[<span class="string">"a"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>],[<span class="string">"aa"</span>,<span class="string">"b"</span>]]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"a"</span></span><br><span class="line">输出：[[<span class="string">"a"</span>]]</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= s.length &lt;= <span class="number">16</span></span><br><span class="line">s 仅由小写英文字母组成</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># fixme:判断是否是回文串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> s == s[::<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        最终的结果，每个字符单独拿出来肯定是一个回文串, 因此不存在空字符串结果的情况，除非输入就是空串</span></span><br><span class="line"><span class="string">        算法考虑的话，有两种方法:</span></span><br><span class="line"><span class="string">            1. 动态规划</span></span><br><span class="line"><span class="string">            2. 回溯法</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.res = []</span><br><span class="line">        <span class="comment"># 回溯法</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(s, path)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">                tt = copy.copy(path) <span class="comment"># 如果直接用self.res.append(path)的话，由于是浅拷贝，后面再path.remove的话，res中的结果也会被修改</span></span><br><span class="line">                self.res.append(tt)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s) + <span class="number">1</span>):  <span class="comment"># 注意起始和结束位置</span></span><br><span class="line">                <span class="keyword">if</span> self.isPalindrome(s[:i]):</span><br><span class="line">                    path.append(s[:i])</span><br><span class="line">                    backtrack(s[i:], path)</span><br><span class="line">                    path.remove(s[:i])</span><br><span class="line">        backtrack(s,[])</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.partition(<span class="string">"a"</span>))</span><br></pre></td></tr></table></figure><h3 id="更加推荐的写法"><a class="header-anchor" href="#更加推荐的写法">¶</a>更加推荐的写法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># fixme:判断是否是回文串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> s == s[::<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        最终的结果，每个字符单独拿出来肯定是一个回文串, 因此不存在空字符串结果的情况，除非输入就是空串</span></span><br><span class="line"><span class="string">        算法考虑的话，有两种方法:</span></span><br><span class="line"><span class="string">            1. 动态规划</span></span><br><span class="line"><span class="string">            2. 回溯法</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 回溯法</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(s, res, path)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">                res.append(path)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s) + <span class="number">1</span>):  <span class="comment"># 注意起始和结束位置</span></span><br><span class="line">                <span class="keyword">if</span> self.isPalindrome(s[:i]):</span><br><span class="line">                    backtrack(s[i:], res, path + [s[:i]])</span><br><span class="line">        backtrack(s,res,[])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第131题—分隔回文串&lt;/h1&gt;
&lt;p&gt;昨天端午鸽了塞&lt;/p&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎S
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>PyCharm连接远程服务器</title>
    <link href="www.strivezs.com/2021/06/10/PyCharm%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>www.strivezs.com/2021/06/10/PyCharm%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2021-06-10T04:48:12.812Z</published>
    <updated>2021-06-10T04:48:12.812Z</updated>
    
    <content type="html"><![CDATA[<h1>PyCharm连接远程服务器</h1><p>使用PyCharm连接远程服务器，并使用服务器的解释器和代码文件来进行运行。</p><h2 id="配置Deplotment"><a class="header-anchor" href="#配置Deplotment">¶</a>配置Deplotment</h2><p>在这之前首先建议，要单独创建一个项目文件夹，因为当前项目的文件都会被自动上传上去。</p><p><img src="https://pic1.zhimg.com/80/v2-b499139f685fe9d8615d4287c0bff230_1440w.jpg" alt="figure.1"></p><p><img src="https://pic3.zhimg.com/80/v2-c2be0d6a5587784bcac2658aac39d106_1440w.jpg" alt="figure.2"></p><p>选择你的服务器的地址和你本地的地址:</p><p><img src="https://pic4.zhimg.com/80/v2-ad6ee2f63c3d36236a5c796f7810aa2f_1440w.jpg" alt="figure.3"></p><h2 id="配置解释器"><a class="header-anchor" href="#配置解释器">¶</a>配置解释器</h2><p>该项目现在使用的就是远程服务器上的Python解释器了。以后的项目若想/不想使用该解释器，手动更改解释器即可。<br>目前来说直接配置解释器就可以完成上面的Deployment的操作.</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/D2JQ9A.png" alt="figure.4"></p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/G8MUAj.png" alt="figure.5"></p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/V9UfmX.png" alt="figure.6"></p><h2 id="测试"><a class="header-anchor" href="#测试">¶</a>测试</h2><p>新建一个文件，然后同步上去直接使用如下代码进行测试:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">print</span>(<span class="string">'hello'</span>)</span><br><span class="line">import torch</span><br><span class="line">flag = torch.cuda.is_available()</span><br><span class="line"><span class="builtin-name">print</span>(flag)</span><br><span class="line">ngpu= 1</span><br><span class="line"><span class="comment"># Decide which device we want to run on</span></span><br><span class="line">device = torch.device(<span class="string">"cuda:0"</span> <span class="keyword">if</span> (torch.cuda.is_available() <span class="keyword">and</span> ngpu &gt; 0) <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line"><span class="builtin-name">print</span>(device)</span><br><span class="line"><span class="builtin-name">print</span>(torch.cuda.get_device_name(0))</span><br><span class="line"><span class="builtin-name">print</span>(torch.rand(3,3).cuda())</span><br></pre></td></tr></table></figure><p>出现如下结果:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">True</span><br><span class="line">cuda:<span class="number">0</span></span><br><span class="line">GeForce RTX <span class="number">2080</span></span><br><span class="line">tensor([[<span class="number">0.3170</span>, <span class="number">0.4412</span>, <span class="number">0.3377</span>],</span><br><span class="line">        [<span class="number">0.5438</span>, <span class="number">0.0894</span>, <span class="number">0.6420</span>],</span><br><span class="line">        [<span class="number">0.0981</span>, <span class="number">0.2753</span>, <span class="number">0.0179</span>]], device=<span class="string">'cuda:0'</span>)</span><br></pre></td></tr></table></figure><p>则表明成功了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;PyCharm连接远程服务器&lt;/h1&gt;
&lt;p&gt;使用PyCharm连接远程服务器，并使用服务器的解释器和代码文件来进行运行。&lt;/p&gt;
&lt;h2 id=&quot;配置Deplotment&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#配置Deplotment&quot;&gt;¶&lt;
      
    
    </summary>
    
    
      <category term="Python" scheme="www.strivezs.com/categories/Python/"/>
    
    
      <category term="Python" scheme="www.strivezs.com/tags/Python/"/>
    
      <category term="PyCharm" scheme="www.strivezs.com/tags/PyCharm/"/>
    
      <category term="Linux" scheme="www.strivezs.com/tags/Linux/"/>
    
      <category term="服务器" scheme="www.strivezs.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.130</title>
    <link href="www.strivezs.com/2021/06/10/LeetCode%E7%AC%AC130%E9%A2%98/"/>
    <id>www.strivezs.com/2021/06/10/LeetCode%E7%AC%AC130%E9%A2%98/</id>
    <published>2021-06-10T04:45:26.129Z</published>
    <updated>2021-06-10T04:45:26.129Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第130题—被围绕的区域</h1><p>恢复正常！！</p><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你一个 m x n 的矩阵 board ，由若干字符 ‘X’ 和 ‘O’ ，找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg" alt="figure.1"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：board = [[<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>],[<span class="string">"X"</span>,<span class="string">"O"</span>,<span class="string">"O"</span>,<span class="string">"X"</span>],[<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"O"</span>,<span class="string">"X"</span>],[<span class="string">"X"</span>,<span class="string">"O"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>]]</span><br><span class="line">输出：[[<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>],[<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>],[<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>],[<span class="string">"X"</span>,<span class="string">"O"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>]]</span><br><span class="line">解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 <span class="string">'O'</span> 都不会被填充为 <span class="string">'X'</span>。 任何不在边界上，或不与边界上的 <span class="string">'O'</span> 相连的 <span class="string">'O'</span> 最终都会被填充为 <span class="string">'X'</span>。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：board = [[<span class="string">"X"</span>]]</span><br><span class="line">输出：[[<span class="string">"X"</span>]]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">m == board.length</span><br><span class="line">n == board[i].length</span><br><span class="line"><span class="number">1</span> &lt;= m, n &lt;= <span class="number">200</span></span><br><span class="line">board[i][j] 为 <span class="string">'X'</span> 或 <span class="string">'O'</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># fixme: BFS</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">BFS</span><span class="params">(self,board, row, col)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param board: List[List]棋盘</span></span><br><span class="line"><span class="string">        :param row: Int 行</span></span><br><span class="line"><span class="string">        :param col: Int 列</span></span><br><span class="line"><span class="string">        :return: Boolean</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        row_limit, col_limit = len(board), len(board[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 检查越界情况</span></span><br><span class="line">        <span class="keyword">if</span> row &lt; <span class="number">0</span> <span class="keyword">or</span> row &gt;= row_limit <span class="keyword">or</span> col &lt; <span class="number">0</span> <span class="keyword">or</span> col &gt;= col_limit:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> board[row][col] == <span class="string">'O'</span>:</span><br><span class="line">            board[row][col] = <span class="string">'#'</span></span><br><span class="line">            <span class="comment"># 上下左右查找</span></span><br><span class="line">            self.BFS(board, row + <span class="number">1</span>, col)</span><br><span class="line">            self.BFS(board, row - <span class="number">1</span>, col)</span><br><span class="line">            self.BFS(board, row, col - <span class="number">1</span>)</span><br><span class="line">            self.BFS(board, row, col + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        考虑BFS，分析可得如果边界存在O的话，则可能会出现不能全部为X的情况，当然也存在边界为O，但是内部全为X的情况</span></span><br><span class="line"><span class="string">        如果边界全为X的话，则必然最终结果全为X</span></span><br><span class="line"><span class="string">        边界上O可到的的O均为不可以变为X的</span></span><br><span class="line"><span class="string">        边界O上不可达的O均为可以变为X的</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(board) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        dim1,dim2 = len(board),len(board[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 从边界非X的开始查找  边界上O可到的的O均为不可以变为X的</span></span><br><span class="line">        <span class="comment">## 上下边界</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(dim1):</span><br><span class="line">            self.BFS(board, i, <span class="number">0</span>)</span><br><span class="line">            self.BFS(board, i, dim2<span class="number">-1</span>)</span><br><span class="line">        <span class="comment">## 左右边界</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(dim2):</span><br><span class="line">            self.BFS(board, <span class="number">0</span>, j)</span><br><span class="line">            self.BFS(board, dim1<span class="number">-1</span>, j)</span><br><span class="line">        <span class="comment"># 处理所有的# # 表示不可以变为X的</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(dim1):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(dim2):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">'#'</span>:</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span></span><br><span class="line">                <span class="keyword">elif</span> board[i][j] == <span class="string">'O'</span>:</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print((s.solve(board = [[<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>],[<span class="string">"X"</span>,<span class="string">"O"</span>,<span class="string">"O"</span>,<span class="string">"X"</span>],[<span class="string">"X"</span>,<span class="string">"X"</span>,<span class="string">"O"</span>,<span class="string">"X"</span>],[<span class="string">"X"</span>,<span class="string">"O"</span>,<span class="string">"X"</span>,<span class="string">"X"</span>]])))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第130题—被围绕的区域&lt;/h1&gt;
&lt;p&gt;恢复正常！！&lt;/p&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎S
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.129</title>
    <link href="www.strivezs.com/2021/06/09/LeetCode%E7%AC%AC129%E9%A2%98/"/>
    <id>www.strivezs.com/2021/06/09/LeetCode%E7%AC%AC129%E9%A2%98/</id>
    <published>2021-06-09T12:43:52.655Z</published>
    <updated>2021-06-09T12:43:52.655Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第129题—求根节点到叶节点数字之和</h1><p>好久没更新了，最近事情太多了，天天忙的要死，英语也没来得及背，后面会慢慢恢复的，同时也会更新一大堆学习到的东西，敬请期待。</p><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。<br>每条从根节点到叶节点的路径都代表一个数字：</p><p>例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。<br>计算从根节点到叶节点生成的 所有数字之和 。</p><p>叶节点 是指没有子节点的节点。</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">25</span></span><br><span class="line">解释：</span><br><span class="line">从根到叶子节点路径 <span class="number">1</span>-&gt;<span class="number">2</span> 代表数字 <span class="number">12</span></span><br><span class="line">从根到叶子节点路径 <span class="number">1</span>-&gt;<span class="number">3</span> 代表数字 <span class="number">13</span></span><br><span class="line">因此，数字总和 = <span class="number">12</span> + <span class="number">13</span> = <span class="number">25</span></span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg" alt="figure.2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line">输入：root = [<span class="number">4</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1026</span></span><br><span class="line">解释：</span><br><span class="line">从根到叶子节点路径 <span class="number">4</span>-&gt;<span class="number">9</span>-&gt;<span class="number">5</span> 代表数字 <span class="number">495</span></span><br><span class="line">从根到叶子节点路径 <span class="number">4</span>-&gt;<span class="number">9</span>-&gt;<span class="number">1</span> 代表数字 <span class="number">491</span></span><br><span class="line">从根到叶子节点路径 <span class="number">4</span>-&gt;<span class="number">0</span> 代表数字 <span class="number">40</span></span><br><span class="line">因此，数字总和 = <span class="number">495</span> + <span class="number">491</span> + <span class="number">40</span> = <span class="number">1026</span></span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中节点的数目在范围 [<span class="number">1</span>, <span class="number">1000</span>] 内</span><br><span class="line"><span class="number">0</span> &lt;= Node.val &lt;= <span class="number">9</span></span><br><span class="line">树的深度不超过 <span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, node, curStr)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">            curStr += str(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right == <span class="literal">None</span> <span class="keyword">and</span> node.left == <span class="literal">None</span>:</span><br><span class="line">                self.sum += int(curStr)</span><br><span class="line">            self.dfs(node.left, curStr)</span><br><span class="line">            self.dfs(node.right, curStr)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        D FS 强制类型转换并且记录就好了</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.sum =<span class="number">0</span></span><br><span class="line">        self.dfs(root, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">return</span> self.sum</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    root = TreeNode(<span class="number">1</span>)</span><br><span class="line">    node1 = TreeNode(<span class="number">2</span>)</span><br><span class="line">    node2 = TreeNode(<span class="number">3</span>)</span><br><span class="line">    root.left = node1</span><br><span class="line">    root.right = node2</span><br><span class="line">    print(s.sumNumbers(root))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第129题—求根节点到叶节点数字之和&lt;/h1&gt;
&lt;p&gt;好久没更新了，最近事情太多了，天天忙的要死，英语也没来得及背，后面会慢慢恢复的，同时也会更新一大堆学习到的东西，敬请期待。&lt;/p&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://githu
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.128</title>
    <link href="www.strivezs.com/2021/06/08/LeetCode%E7%AC%AC128%E9%A2%98/"/>
    <id>www.strivezs.com/2021/06/08/LeetCode%E7%AC%AC128%E9%A2%98/</id>
    <published>2021-06-08T15:17:48.827Z</published>
    <updated>2021-06-08T15:17:48.827Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第128题—最长连续序列</h1><p>好久没更新了，最近事情太多了，天天忙的要死，英语也没来得及背，后面会慢慢恢复的，同时也会更新一大堆学习到的东西，敬请期待。</p><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>进阶：你可以设计并实现时间复杂度为 O(n) 的解决方案吗？</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">100</span>,<span class="number">4</span>,<span class="number">200</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最长数字连续序列是 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]。它的长度为 <span class="number">4</span>。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &lt;= nums.length &lt;= <span class="number">104</span></span><br><span class="line"><span class="number">-109</span> &lt;= nums[i] &lt;= <span class="number">109</span></span><br><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想:</span></span><br><span class="line"><span class="string">            考虑用字典存储当前长度</span></span><br><span class="line"><span class="string">            dict[a] = b 表示这个每个端点值对应连续区间的长度</span></span><br><span class="line"><span class="string">            键值是顺序从小到大的</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        max_length = <span class="number">0</span></span><br><span class="line">        res_dict = dict()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 去掉重复情况</span></span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> res_dict.keys():</span><br><span class="line">                <span class="comment"># 找到它的左端值和右端值</span></span><br><span class="line">                left_length = res_dict.get(num<span class="number">-1</span>,<span class="number">0</span>) <span class="comment"># 如果左边值存在则和左边值连续，否则返回0</span></span><br><span class="line">                right_length = res_dict.get(num+<span class="number">1</span>,<span class="number">0</span>) <span class="comment"># 如果右边值存在，则和右边值连续，否则返回0</span></span><br><span class="line">                length = left_length + right_length + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> length &gt; max_length:</span><br><span class="line">                    max_length = length</span><br><span class="line">                <span class="comment"># 更新字典值</span></span><br><span class="line">                res_dict[num] = length</span><br><span class="line">                <span class="comment"># 更新左邻域最大长度(没有的话不更新)</span></span><br><span class="line">                res_dict[num-left_length] = length</span><br><span class="line">                <span class="comment"># 更新有邻域最大长度(如果没有的话，则不更新)</span></span><br><span class="line">                res_dict[num+right_length] = length</span><br><span class="line">        <span class="keyword">return</span> max_length</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第128题—最长连续序列&lt;/h1&gt;
&lt;p&gt;好久没更新了，最近事情太多了，天天忙的要死，英语也没来得及背，后面会慢慢恢复的，同时也会更新一大堆学习到的东西，敬请期待。&lt;/p&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.127</title>
    <link href="www.strivezs.com/2021/06/03/LeetCode%E7%AC%AC127%E9%A2%98/"/>
    <id>www.strivezs.com/2021/06/03/LeetCode%E7%AC%AC127%E9%A2%98/</id>
    <published>2021-06-03T11:56:11.305Z</published>
    <updated>2021-06-03T11:56:11.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第127题—单词接龙"><a href="#LeetCode第127题—单词接龙" class="headerlink" title="LeetCode第127题—单词接龙"></a>LeetCode第127题—单词接龙</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：</p><p>序列中第一个单词是 beginWord 。<br>序列中最后一个单词是 endWord 。<br>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典 wordList 中的单词。<br>给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="keyword">begin</span>Word = <span class="string">"hit"</span>, <span class="keyword">end</span>Word = <span class="string">"cog"</span>, wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>,<span class="string">"cog"</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：一个最短转换序列是 <span class="string">"hit"</span> -&gt; <span class="string">"hot"</span> -&gt; <span class="string">"dot"</span> -&gt; <span class="string">"dog"</span> -&gt; <span class="string">"cog"</span>, 返回它的长度 <span class="number">5</span>。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="keyword">begin</span>Word = <span class="string">"hit"</span>, <span class="keyword">end</span>Word = <span class="string">"cog"</span>, wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：<span class="keyword">end</span>Word <span class="string">"cog"</span> 不在字典中，所以无法进行转换。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= <span class="keyword">begin</span>Word.length &lt;= <span class="number">10</span></span><br><span class="line"><span class="keyword">end</span>Word.length == <span class="keyword">begin</span>Word.length</span><br><span class="line"><span class="number">1</span> &lt;= wordList.length &lt;= <span class="number">5000</span></span><br><span class="line">wordList[i].length == <span class="keyword">begin</span>Word.length</span><br><span class="line"><span class="keyword">begin</span>Word、<span class="keyword">end</span>Word 和 wordList[i] 由小写英文字母组成</span><br><span class="line"><span class="keyword">begin</span>Word != <span class="keyword">end</span>Word</span><br><span class="line">wordList 中的所有字符串 互不相同</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><img src="https://gitee.com/zyp521/upload_image/raw/master/OJ.png" alt="figure.1"></p><p>Python使用BFS的话，还是会超时，最长的那个过不去，这里就参考大佬的方法。<br>反正都是小写字母，每次只变动一位，干脆拿到一个节点时生成所有可能的下一个节点，新生成的节点只要再列表中就参与计算。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="使用了邻接矩阵的超时版本"><a href="#使用了邻接矩阵的超时版本" class="headerlink" title="使用了邻接矩阵的超时版本"></a>使用了邻接矩阵的超时版本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">one_chart_different</span><span class="params">(self, str1, str2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        判断输入的两个字符串是不是只有一个不一样, 默认输入的两个字符串长度相同</span></span><br><span class="line"><span class="string">        :param str1: String</span></span><br><span class="line"><span class="string">        :param str2: String</span></span><br><span class="line"><span class="string">        :return: Boolean True/False</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(str1)):</span><br><span class="line">            <span class="keyword">if</span> str1[i] != str2[i]:</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="comment"># fixme: 使用BFS进行广度优先搜索</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">BFS_memory_search</span><span class="params">(self, start, end_num, adjacent_matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        使用带有记忆的BFS来进行搜索，层数逐渐增加就可以了，直到最先扩展到最终节点就结束</span></span><br><span class="line"><span class="string">        有点类似树扩展的方法,用字典来记录深度</span></span><br><span class="line"><span class="string">        :param start: Int 给点初始节点在邻接矩阵中的下标</span></span><br><span class="line"><span class="string">        :param end_num: 终止节点</span></span><br><span class="line"><span class="string">        :param adjacent_matrix: 邻接矩阵</span></span><br><span class="line"><span class="string">        :return: distance, path 返回距离和路径</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        inf = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="comment"># 初始化操作</span></span><br><span class="line">        depth_dict = &#123;&#125; <span class="comment"># 记忆深度词典</span></span><br><span class="line">        depth_dict[start] = <span class="number">1</span> <span class="comment"># 初始化</span></span><br><span class="line">        quene = [] <span class="comment"># 队列</span></span><br><span class="line">        quene.append(start)</span><br><span class="line">        n = len(adjacent_matrix) <span class="comment"># 节点个数</span></span><br><span class="line">        step = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> len(quene) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> step</span><br><span class="line">            node = quene.pop(<span class="number">0</span>) <span class="comment"># 队首出列</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> adjacent_matrix[node][j] != inf <span class="keyword">and</span> j <span class="keyword">not</span> <span class="keyword">in</span> depth_dict.keys(): <span class="comment"># 证明可以扩展</span></span><br><span class="line">                    quene.append(j) <span class="comment"># 入队</span></span><br><span class="line">                    depth_dict[j] = depth_dict[node] + <span class="number">1</span> <span class="comment"># 深度记录</span></span><br><span class="line">                <span class="keyword">if</span> j == end_num <span class="keyword">and</span> end_num <span class="keyword">in</span> depth_dict.keys():</span><br><span class="line">                    step = depth_dict[j]</span><br><span class="line">                    <span class="keyword">return</span> step</span><br><span class="line">        <span class="keyword">return</span> step</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span><span class="params">(self, beginWord, endWord, wordList)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type beginWord: str</span></span><br><span class="line"><span class="string">        :type endWord: str</span></span><br><span class="line"><span class="string">        :type wordList: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        根据给定的字典list构造一个图，考虑使用邻接矩阵构建一个图</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        inf = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> beginWord <span class="keyword">not</span> <span class="keyword">in</span> wordList:</span><br><span class="line">            nodeList = [beginWord] + wordList  <span class="comment"># 构造所有节点列表</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nodeList = wordList</span><br><span class="line">            nodeList.remove(nodeList[nodeList.index(beginWord)])</span><br><span class="line">            nodeList = [beginWord] + wordList <span class="comment"># 将初始节点至为第一个</span></span><br><span class="line">        numList = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nodeList))] <span class="comment"># 构造每个节点对应的数字状态</span></span><br><span class="line">        node_num_dict = dict(zip(nodeList,numList)) <span class="comment"># 构建对应关系的字典</span></span><br><span class="line">        num_node_dict = dict(zip(numList,nodeList)) <span class="comment"># 构造反向对应关系</span></span><br><span class="line">        adjacent_matrix = [[inf <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nodeList))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nodeList))] <span class="comment"># 邻接矩阵</span></span><br><span class="line">        <span class="comment"># 构建邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nodeList:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nodeList:</span><br><span class="line">                <span class="keyword">if</span> i != j:</span><br><span class="line">                    <span class="keyword">if</span> len(i) == len(j):</span><br><span class="line">                        <span class="keyword">if</span> self.one_chart_different(i,j):</span><br><span class="line">                            adjacent_matrix[node_num_dict[i]][node_num_dict[j]] = <span class="number">1</span></span><br><span class="line">                            adjacent_matrix[node_num_dict[j]][node_num_dict[i]] = <span class="number">1</span></span><br><span class="line">        step = self.BFS_memory_search(<span class="number">0</span>,nodeList.index(endWord),adjacent_matrix)</span><br><span class="line">        <span class="keyword">if</span> step == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> step</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.ladderLength(beginWord = <span class="string">"talk"</span>, endWord = <span class="string">"tail"</span>, wordList = [<span class="string">"talk"</span>,<span class="string">"tons"</span>,<span class="string">"fall"</span>,<span class="string">"tail"</span>,<span class="string">"gale"</span>,<span class="string">"hall"</span>,<span class="string">"negs"</span>]))</span><br></pre></td></tr></table></figure><h3 id="去掉邻接矩阵直接判断的版本"><a href="#去掉邻接矩阵直接判断的版本" class="headerlink" title="去掉邻接矩阵直接判断的版本"></a>去掉邻接矩阵直接判断的版本</h3><p>别人没超时，我用Python又又超时了，我爆哭.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">one_chart_different</span><span class="params">(self, str1, str2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        判断输入的两个字符串是不是只有一个不一样, 默认输入的两个字符串长度相同</span></span><br><span class="line"><span class="string">        :param str1: String</span></span><br><span class="line"><span class="string">        :param str2: String</span></span><br><span class="line"><span class="string">        :return: Boolean True/False</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(str1)):</span><br><span class="line">            <span class="keyword">if</span> str1[i] != str2[i]:</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_version</span><span class="params">(self, beginWord, endWord, wordList)</span>:</span></span><br><span class="line">        quene = []</span><br><span class="line">        quene.append(beginWord)</span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> len(quene) != <span class="number">0</span>:</span><br><span class="line">            step += <span class="number">1</span></span><br><span class="line">            sz = len(quene)</span><br><span class="line">            <span class="keyword">while</span> sz &gt; <span class="number">0</span>:</span><br><span class="line">                hope = quene.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> hope == endWord:</span><br><span class="line">                    <span class="keyword">return</span> step</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 对每个word进行判断</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(wordList)):</span><br><span class="line">                    <span class="keyword">if</span> len(wordList[i]) == <span class="number">0</span> <span class="keyword">or</span> len(wordList[i]) != len(beginWord):</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment"># 判断差异性</span></span><br><span class="line">                    <span class="keyword">if</span> self.one_chart_different(hope,wordList[i]):</span><br><span class="line">                        quene.append(wordList[i])</span><br><span class="line">                        wordList[i] = <span class="string">""</span></span><br><span class="line">                sz -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.new_version(beginWord = <span class="string">"hit"</span>, endWord = <span class="string">"cog"</span>, wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>]))</span><br></pre></td></tr></table></figure></p><h3 id="参考大佬的版本"><a href="#参考大佬的版本" class="headerlink" title="参考大佬的版本"></a>参考大佬的版本</h3><p>反正都是小写字母，每次只变动一位，干脆拿到一个节点时生成所有可能的下一个节点，新生成的节点只要再列表中就参与计算。</p><p>这次终于通过了，不过耗时几百毫秒。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">def ladderLength(self, beginWord: str, endWord: str, wordLis<span class="variable">t:</span> List[str]) -&gt; in<span class="variable">t:</span></span><br><span class="line">        <span class="keyword">if</span> endWord not in wordLis<span class="variable">t:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">l</span> = <span class="built_in">len</span>(endWord)</span><br><span class="line">        </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">ws</span> = <span class="keyword">set</span>(wordList)</span><br><span class="line">        </span><br><span class="line">        head = &#123;beginWord&#125;</span><br><span class="line">        tail = &#123;endWord&#125;</span><br><span class="line">        tmp = <span class="keyword">list</span>(<span class="string">'abcdefghijklmnopqrstuvwxyz'</span>)</span><br><span class="line">        <span class="keyword">res</span> = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(head) &gt; <span class="built_in">len</span>(tail):</span><br><span class="line">                head, tail = tail, head</span><br><span class="line">            </span><br><span class="line">            q = <span class="keyword">set</span>()</span><br><span class="line">            <span class="keyword">for</span> cur in head:</span><br><span class="line">                <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="keyword">l</span>):</span><br><span class="line">                    <span class="keyword">for</span> <span class="keyword">j</span> in tmp:</span><br><span class="line">                        word = cur[:i] + <span class="keyword">j</span> + cur[i+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> word in tai<span class="variable">l:</span></span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">res</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> word in <span class="keyword">w</span><span class="variable">s:</span></span><br><span class="line">                            q.<span class="built_in">add</span>(word)</span><br><span class="line">                            <span class="keyword">ws</span>.<span class="built_in">remove</span>(word)</span><br><span class="line">            head = q</span><br><span class="line">            <span class="keyword">res</span> += <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第127题—单词接龙&quot;&gt;&lt;a href=&quot;#LeetCode第127题—单词接龙&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第127题—单词接龙&quot;&gt;&lt;/a&gt;LeetCode第127题—单词接龙&lt;/h1&gt;&lt;p&gt;自己代码的开
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.126</title>
    <link href="www.strivezs.com/2021/06/02/LeetCode%E7%AC%AC126%E9%A2%98/"/>
    <id>www.strivezs.com/2021/06/02/LeetCode%E7%AC%AC126%E9%A2%98/</id>
    <published>2021-06-02T08:57:37.483Z</published>
    <updated>2021-06-02T08:57:37.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第126题—单词接龙II"><a href="#LeetCode第126题—单词接龙II" class="headerlink" title="LeetCode第126题—单词接龙II"></a>LeetCode第126题—单词接龙II</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的 转换序列 是形式上像 beginWord -&gt; s1 -&gt; s2 -&gt; … -&gt; sk 这样的单词序列，并满足：</p><p>每对相邻的单词之间仅有单个字母不同。<br>转换过程中的每个单词 si（1 &lt;= i &lt;= k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordList 中的单词。<br>sk == endWord<br>给你两个单词 beginWord 和 endWord ，以及一个字典 wordList 。请你找出并返回所有从 beginWord 到 endWord 的 最短转换序列 ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 [beginWord, s1, s2, …, sk] 的形式返回。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="keyword">begin</span>Word = <span class="string">"hit"</span>, <span class="keyword">end</span>Word = <span class="string">"cog"</span>, wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>,<span class="string">"cog"</span>]</span><br><span class="line">输出：[[<span class="string">"hit"</span>,<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"cog"</span>],[<span class="string">"hit"</span>,<span class="string">"hot"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>,<span class="string">"cog"</span>]]</span><br><span class="line">解释：存在 <span class="number">2</span> 种最短的转换序列：</span><br><span class="line"><span class="string">"hit"</span> -&gt; <span class="string">"hot"</span> -&gt; <span class="string">"dot"</span> -&gt; <span class="string">"dog"</span> -&gt; <span class="string">"cog"</span></span><br><span class="line"><span class="string">"hit"</span> -&gt; <span class="string">"hot"</span> -&gt; <span class="string">"lot"</span> -&gt; <span class="string">"log"</span> -&gt; <span class="string">"cog"</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="keyword">begin</span>Word = <span class="string">"hit"</span>, <span class="keyword">end</span>Word = <span class="string">"cog"</span>, wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>]</span><br><span class="line">输出：[]</span><br><span class="line">解释：<span class="keyword">end</span>Word <span class="string">"cog"</span> 不在字典 wordList 中，所以不存在符合要求的转换序列。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= <span class="keyword">begin</span>Word.length &lt;= <span class="number">7</span></span><br><span class="line"><span class="keyword">end</span>Word.length == <span class="keyword">begin</span>Word.length</span><br><span class="line"><span class="number">1</span> &lt;= wordList.length &lt;= <span class="number">5000</span></span><br><span class="line">wordList[i].length == <span class="keyword">begin</span>Word.length</span><br><span class="line"><span class="keyword">begin</span>Word、<span class="keyword">end</span>Word 和 wordList[i] 由小写英文字母组成</span><br><span class="line"><span class="keyword">begin</span>Word != <span class="keyword">end</span>Word</span><br><span class="line">wordList 中的所有单词 互不相同</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><img src="https://gitee.com/zyp521/upload_image/raw/master/IMG_0713.PNG" alt="figure.1"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>回溯法做的. 不知道为什么，我写的代码，一个测试用例提交报错，我同样在本地测试一点问题都没有。不知道啥情况了，代码整体思想没有问题。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def one_chart_different(self, str1, str2):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        判断输入的两个字符串是不是只有一个不一样, 默认输入的两个字符串长度相同</span><br><span class="line">        :param str1: String</span><br><span class="line">        :param str2: String</span><br><span class="line">        :<span class="keyword">return</span>: Boolean True/False</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(str1)):</span><br><span class="line">            <span class="keyword">if</span> str1[i] != str2[i]:</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> False</span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> False</span><br><span class="line">        <span class="keyword">return</span> True</span><br><span class="line">    # fixme: BFS深度度优先搜索寻找最短路径 实质上就是暴力搜索  回溯法</span><br><span class="line">    res_path = dict()</span><br><span class="line">    min_dist = float(<span class="string">'inf'</span>)</span><br><span class="line">    def BFS_Search(self, start, ends, path, visited, adjacent_matrix):</span><br><span class="line">        inf = float(<span class="string">'inf'</span>)</span><br><span class="line">        # 如果满足则存储路径和距离</span><br><span class="line">        <span class="keyword">if</span> start == end<span class="variable">s:</span></span><br><span class="line">            path_node = path.<span class="keyword">split</span>(<span class="string">','</span>)</span><br><span class="line">            distance = <span class="built_in">len</span>(path_node)</span><br><span class="line">            <span class="keyword">if</span> distance &lt; self.min_dis<span class="variable">t:</span></span><br><span class="line">                self.min_dist = distance</span><br><span class="line">            <span class="keyword">if</span> path not in self.res_path.<span class="built_in">keys</span>():</span><br><span class="line">                self.res_path[path] = distance</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">len</span>(adjacent_matrix)</span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> adjacent_matrix[start][i] != inf <span class="built_in">and</span> not visited[i]:</span><br><span class="line">                t = path</span><br><span class="line">                path = path + <span class="string">','</span> + str(i)</span><br><span class="line">                visited[i] = True</span><br><span class="line">                self.BFS_Search(i, ends, path, visited, adjacent_matrix)</span><br><span class="line">                path = t</span><br><span class="line">                visited[i] = False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def findLadders(self, beginWord, endWord, wordList):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        :<span class="built_in">type</span> beginWord: str</span><br><span class="line">        :<span class="built_in">type</span> endWord: str</span><br><span class="line">        :<span class="built_in">type</span> wordLis<span class="variable">t:</span> List[str]</span><br><span class="line">        :rtype: List[List[str]]</span><br><span class="line">        根据给定的字典<span class="keyword">list</span>构造一个图，考虑使用邻接矩阵构建一个图</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        inf = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">if</span> endWord not in wordLis<span class="variable">t:</span></span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> beginWord not in wordLis<span class="variable">t:</span></span><br><span class="line">            nodeList = [beginWord] + wordList  # 构造所有节点列表</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nodeList = wordList</span><br><span class="line">        numList = [i <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(nodeList))] # 构造每个节点对应的数字状态</span><br><span class="line">        node_num_dict = dict(zip(nodeList,numList)) # 构建对应关系的字典</span><br><span class="line">        num_node_dict = dict(zip(numList,nodeList)) # 构造反向对应关系</span><br><span class="line">        adjacent_matrix = [[inf <span class="keyword">for</span> _ in <span class="built_in">range</span>(<span class="built_in">len</span>(nodeList))] <span class="keyword">for</span> _ in <span class="built_in">range</span>(<span class="built_in">len</span>(nodeList))] # 邻接矩阵</span><br><span class="line">        # 构建邻接矩阵</span><br><span class="line">        <span class="keyword">for</span> i in nodeLis<span class="variable">t:</span></span><br><span class="line">            <span class="keyword">for</span> <span class="keyword">j</span> in nodeLis<span class="variable">t:</span></span><br><span class="line">                <span class="keyword">if</span> i != <span class="keyword">j</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(i) == <span class="built_in">len</span>(<span class="keyword">j</span>):</span><br><span class="line">                        <span class="keyword">if</span> self.one_chart_different(i,<span class="keyword">j</span>):</span><br><span class="line">                            adjacent_matrix[node_num_dict[i]][node_num_dict[<span class="keyword">j</span>]] = <span class="number">1</span></span><br><span class="line">                            adjacent_matrix[node_num_dict[<span class="keyword">j</span>]][node_num_dict[i]] = <span class="number">1</span></span><br><span class="line">        # 使用BFS回溯法搜索</span><br><span class="line">        visited = [False] * <span class="built_in">len</span>(adjacent_matrix)</span><br><span class="line">        visited[<span class="number">0</span>] = True</span><br><span class="line">        self.BFS_Search(nodeList.<span class="built_in">index</span>(beginWord),nodeList.<span class="built_in">index</span>(endWord),str(nodeList.<span class="built_in">index</span>(beginWord)),visited,adjacent_matrix)</span><br><span class="line">        <span class="keyword">res</span> = []</span><br><span class="line">        <span class="keyword">for</span> item in self.res_path.<span class="built_in">keys</span>():</span><br><span class="line">            <span class="keyword">if</span> self.res_path[item] == self.min_dis<span class="variable">t:</span></span><br><span class="line">                temp = []</span><br><span class="line">                path = item.<span class="keyword">split</span>(<span class="string">','</span>)</span><br><span class="line">                <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(path)):</span><br><span class="line">                    temp.<span class="keyword">append</span>(num_node_dict[<span class="keyword">int</span>(path[i])])</span><br><span class="line">                <span class="keyword">res</span>.<span class="keyword">append</span>(temp)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="keyword">print</span>(s.findLadders(beginWord = <span class="string">"hot"</span>, endWord = <span class="string">"dog"</span>, wordList = [<span class="string">"hot"</span>,<span class="string">"dog"</span>,<span class="string">"dot"</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第126题—单词接龙II&quot;&gt;&lt;a href=&quot;#LeetCode第126题—单词接龙II&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第126题—单词接龙II&quot;&gt;&lt;/a&gt;LeetCode第126题—单词接龙II&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 基于邻接矩阵的Dijkstra算法</title>
    <link href="www.strivezs.com/2021/06/02/%E5%9F%BA%E4%BA%8E%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84Dijkstra%E7%AE%97%E6%B3%95/"/>
    <id>www.strivezs.com/2021/06/02/%E5%9F%BA%E4%BA%8E%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84Dijkstra%E7%AE%97%E6%B3%95/</id>
    <published>2021-06-02T08:52:14.412Z</published>
    <updated>2021-06-02T08:52:14.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于邻接矩阵的Dijkstra算法"><a href="#基于邻接矩阵的Dijkstra算法" class="headerlink" title="基于邻接矩阵的Dijkstra算法"></a>基于邻接矩阵的Dijkstra算法</h1><p>如果你的图不是邻接矩阵，转换成矩阵的形式就可以了。这里节点我就是用index表示的。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">fixme:</span> Dijkstra算法寻找最短路径，从给定初始点到每个节点的最短路径</span></span><br><span class="line">    def Dijkstra(self, <span class="keyword">start</span>, adjacent_matrix):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param start: Int 给点初始节点在邻接矩阵中的下标</span></span><br><span class="line"><span class="string">        :param adjacent_matrix: 邻接矩阵</span></span><br><span class="line"><span class="string">        :return: distance, path 返回到每个节点的最短距离，返回路径</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 初始化操作</span></span><br><span class="line">        n = <span class="keyword">len</span>(adjacent_matrix) <span class="comment"># 节点个数</span></span><br><span class="line">        inf = <span class="built_in">float</span>(<span class="string">'inf'</span>)</span><br><span class="line">        distance = [inf] * n <span class="comment"># 用于存放从某个点到其他点的最短路径长度</span></span><br><span class="line">        <span class="keyword">path</span> = [<span class="keyword">None</span>] * n <span class="comment"># 用于存放从初始点到其他点的路径</span></span><br><span class="line">        <span class="keyword">final</span> = [<span class="keyword">None</span>] * n <span class="comment"># 用于存放从初始点到其他点的最短路径</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(n):</span><br><span class="line">            <span class="keyword">final</span>[i] = <span class="literal">False</span></span><br><span class="line">            distance[i] = adjacent_matrix[<span class="keyword">start</span>][i]</span><br><span class="line">            <span class="keyword">path</span>[i] = <span class="string">""</span>  <span class="comment"># 路径置空</span></span><br><span class="line">            <span class="keyword">if</span> distance[i] &lt; inf:</span><br><span class="line">                <span class="keyword">path</span>[i] = <span class="keyword">str</span>(i)</span><br><span class="line">        distance[<span class="keyword">start</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">final</span>[<span class="keyword">start</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 算法</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">min</span> = inf</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="keyword">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">final</span>[k] <span class="keyword">and</span> distance[k] &lt; <span class="keyword">min</span>:</span><br><span class="line">                    v = k</span><br><span class="line">                    <span class="keyword">min</span> = distance[k]</span><br><span class="line">            <span class="keyword">final</span>[v] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="keyword">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">final</span>[k] <span class="keyword">and</span> <span class="keyword">min</span> + adjacent_matrix[v][k] &lt; distance[k]:</span><br><span class="line">                    distance[k] = <span class="keyword">min</span> + adjacent_matrix[v][k]</span><br><span class="line">                    <span class="keyword">path</span>[k] = <span class="keyword">path</span>[v] + <span class="string">','</span> + <span class="keyword">str</span>(k)</span><br><span class="line">        <span class="keyword">return</span> distance, <span class="keyword">path</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基于邻接矩阵的Dijkstra算法&quot;&gt;&lt;a href=&quot;#基于邻接矩阵的Dijkstra算法&quot; class=&quot;headerlink&quot; title=&quot;基于邻接矩阵的Dijkstra算法&quot;&gt;&lt;/a&gt;基于邻接矩阵的Dijkstra算法&lt;/h1&gt;&lt;p&gt;如果你的图不是邻接矩
      
    
    </summary>
    
    
      <category term="算法" scheme="www.strivezs.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="算法" scheme="www.strivezs.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="www.strivezs.com/tags/%E5%9B%BE/"/>
    
      <category term="最短路径" scheme="www.strivezs.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
      <category term="Dijkstra" scheme="www.strivezs.com/tags/Dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.125</title>
    <link href="www.strivezs.com/2021/06/01/LeetCode%E7%AC%AC125%E9%A2%98/"/>
    <id>www.strivezs.com/2021/06/01/LeetCode%E7%AC%AC125%E9%A2%98/</id>
    <published>2021-06-01T11:17:18.841Z</published>
    <updated>2021-06-01T11:17:18.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第125题—验证回文串"><a href="#LeetCode第125题—验证回文串" class="headerlink" title="LeetCode第125题—验证回文串"></a>LeetCode第125题—验证回文串</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p>说明：本题中，我们将空字符串定义为有效的回文串。<br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="comment">"A man, a plan, a canal: Panama"</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="comment">"race a car"</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></table></figure></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>执行用时：88 ms, 在所有 Python3 提交中击败了7.76%的用户内存消耗：14.9 MB, 在所有 Python3 提交中击败了96.98%的用户<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judeRange</span><span class="params">(self, c)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> c &gt;= <span class="string">'a'</span> <span class="keyword">and</span> c &lt;= <span class="string">'z'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> c &gt;= <span class="string">'A'</span> <span class="keyword">and</span> c &lt;= <span class="string">'Z'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> c &gt;=<span class="string">'0'</span> <span class="keyword">and</span> c &lt;= <span class="string">'9'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        核心思想:</span></span><br><span class="line"><span class="string">            双向指针，自动去除出字母和数字之外的字符串</span></span><br><span class="line"><span class="string">            统一将字母转换为小写</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        ends = len(s)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> start &lt; ends:</span><br><span class="line">            flag1 = self.judeRange(s[start])</span><br><span class="line">            flag2 = self.judeRange(s[ends])</span><br><span class="line">            <span class="keyword">if</span> flag1 <span class="keyword">and</span> flag2:</span><br><span class="line">                s1 = s[start].lower()</span><br><span class="line">                s2 = s[ends].lower()</span><br><span class="line">                <span class="keyword">if</span> s1 != s2:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">                ends -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> flag1 <span class="keyword">and</span> ~flag2:</span><br><span class="line">                ends -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> ~flag1 <span class="keyword">and</span> flag2:</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">                ends -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第125题—验证回文串&quot;&gt;&lt;a href=&quot;#LeetCode第125题—验证回文串&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第125题—验证回文串&quot;&gt;&lt;/a&gt;LeetCode第125题—验证回文串&lt;/h1&gt;&lt;p&gt;自己
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.123=4</title>
    <link href="www.strivezs.com/2021/05/31/LeetCode%E7%AC%AC124%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/31/LeetCode%E7%AC%AC124%E9%A2%98/</id>
    <published>2021-05-31T14:43:30.630Z</published>
    <updated>2021-05-31T14:43:30.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第123题—买卖股票的最佳时机III"><a href="#LeetCode第123题—买卖股票的最佳时机III" class="headerlink" title="LeetCode第123题—买卖股票的最佳时机III"></a>LeetCode第123题—买卖股票的最佳时机III</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p>路径和 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" alt="figure.1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：最优路径是 <span class="number">2</span> -&gt; <span class="number">1</span> -&gt; <span class="number">3</span> ，路径和为 <span class="number">2</span> + <span class="number">1</span> + <span class="number">3</span> = <span class="number">6</span></span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg" alt="figure.2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">-10</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">42</span></span><br><span class="line">解释：最优路径是 <span class="number">15</span> -&gt; <span class="number">20</span> -&gt; <span class="number">7</span> ，路径和为 <span class="number">15</span> + <span class="number">20</span> + <span class="number">7</span> = <span class="number">42</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中节点数目范围是 [<span class="number">1</span>, <span class="number">3</span> * <span class="number">104</span>]</span><br><span class="line"><span class="number">-1000</span> &lt;= Node.val &lt;= <span class="number">1000</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, val=<span class="number">0</span>, left=None, right=None)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.left = left</span><br><span class="line">        <span class="keyword">self</span>.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="title">object</span>):</span></span><br><span class="line">    max_sum = -sys.maxsize</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs_statistic_path</span><span class="params">(<span class="keyword">self</span>, root)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="symbol">None:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_sum = max(<span class="number">0</span>, <span class="keyword">self</span>.dfs_statistic_path(root.left)) <span class="comment"># 统计左子树的路径总和</span></span><br><span class="line">        right_sum = max(<span class="number">0</span>, <span class="keyword">self</span>.dfs_statistic_path(root.right)) <span class="comment"># 统计右子树的路径总和</span></span><br><span class="line">        temp = left_sum + root.val + right_sum <span class="comment"># 统计当前路径总和</span></span><br><span class="line">        <span class="keyword">self</span>.max_sum = max(<span class="keyword">self</span>.max_sum, temp) <span class="comment"># 和当前最大路径进行比较</span></span><br><span class="line">        <span class="keyword">return</span> max(left_sum,right_sum) + root.val <span class="comment"># 由于不能够返回(节点不能够重复)，因此只能选择出最大的一个子树再加上当前根节点值来返回</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span><span class="params">(<span class="keyword">self</span>, root)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        整体上是分而治之的思想，看成一个个子问题</span></span><br><span class="line"><span class="string">        将每个节点看成是它子树的路径和(左子树和右子树)+他本来的值</span></span><br><span class="line"><span class="string">        只有子路径和大于0的时候才会去统计它</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">self</span>.dfs_statistic_path(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.max_sum</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">'__main__'</span><span class="symbol">:</span></span><br><span class="line">    root = TreeNode(<span class="number">1</span>)</span><br><span class="line">    node1 = TreeNode(<span class="number">2</span>)</span><br><span class="line">    node2 = TreeNode(<span class="number">3</span>)</span><br><span class="line">    root.left = node1</span><br><span class="line">    root.right = node2</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.maxPathSum(root))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第123题—买卖股票的最佳时机III&quot;&gt;&lt;a href=&quot;#LeetCode第123题—买卖股票的最佳时机III&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第123题—买卖股票的最佳时机III&quot;&gt;&lt;/a&gt;LeetCode
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.123</title>
    <link href="www.strivezs.com/2021/05/30/LeetCode%E7%AC%AC123%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/30/LeetCode%E7%AC%AC123%E9%A2%98/</id>
    <published>2021-05-30T11:32:17.739Z</published>
    <updated>2021-05-30T11:32:17.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第123题—买卖股票的最佳时机III"><a href="#LeetCode第123题—买卖股票的最佳时机III" class="headerlink" title="LeetCode第123题—买卖股票的最佳时机III"></a>LeetCode第123题—买卖股票的最佳时机III</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入：prices = [<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：在第 <span class="number">4</span> 天（股票价格 = <span class="number">0</span>）的时候买入，在第 <span class="number">6</span> 天（股票价格 = <span class="number">3</span>）的时候卖出，这笔交易所能获得利润 = <span class="number">3</span><span class="number">-0</span> = <span class="number">3</span> 。</span><br><span class="line">     随后，在第 <span class="number">7</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">8</span> 天 （股票价格 = <span class="number">4</span>）的时候卖出，这笔交易所能获得利润 = <span class="number">4</span><span class="number">-1</span> = <span class="number">3</span> 。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：prices = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：在第 <span class="number">1</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天 （股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span><span class="number">-1</span> = <span class="number">4</span> 。   </span><br><span class="line">     注意你不能在第 <span class="number">1</span> 天和第 <span class="number">2</span> 天接连购买股票，之后再将它们卖出。   </span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：prices = [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>] </span><br><span class="line">输出：<span class="number">0</span> </span><br><span class="line">解释：在这个情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：prices = [<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= prices.length &lt;= <span class="number">105</span></span><br><span class="line"><span class="number">0</span> &lt;= prices[i] &lt;= <span class="number">105</span></span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>参考大佬的动态规划思想做出来的。我是菜逼我是菜逼</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/IMG_0712.PNG" alt="figure.1"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        利用动态规划</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(prices) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 五种状态初始化</span></span><br><span class="line">        dp0 = <span class="number">0</span></span><br><span class="line">        dp1 = -prices[<span class="number">0</span>]</span><br><span class="line">        dp2 = -sys.maxsize</span><br><span class="line">        dp3 = -sys.maxsize</span><br><span class="line">        dp4 = -sys.maxsize</span><br><span class="line">        <span class="comment"># 状态转移</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            dp1 = max(dp1, dp0-prices[i]) <span class="comment"># 可能是从dp0买入一笔转移过来的，但是没有卖出因此为-prices[i]，也可能是一直处于dp1没有卖出</span></span><br><span class="line">            dp2 = max(dp2, dp1+prices[i]) <span class="comment"># 可能是从dp1卖出一笔转移过来的，因为卖出了所以为+prices[i],也可能是因为没有买一直停留在dp2</span></span><br><span class="line">            dp3 = max(dp3, dp2-prices[i])</span><br><span class="line">            dp4 = max(dp4, dp3+prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp4 <span class="comment">#返回最终状态，就是最终的利润</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s  = Solution()</span><br><span class="line">    print(s.maxProfit([<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第123题—买卖股票的最佳时机III&quot;&gt;&lt;a href=&quot;#LeetCode第123题—买卖股票的最佳时机III&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第123题—买卖股票的最佳时机III&quot;&gt;&lt;/a&gt;LeetCode
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.122</title>
    <link href="www.strivezs.com/2021/05/29/LeetCode%E7%AC%AC122%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/29/LeetCode%E7%AC%AC122%E9%A2%98/</id>
    <published>2021-05-29T12:46:43.308Z</published>
    <updated>2021-05-29T12:46:43.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第122题—买卖股票的最佳时机II"><a href="#LeetCode第122题—买卖股票的最佳时机II" class="headerlink" title="LeetCode第122题—买卖股票的最佳时机II"></a>LeetCode第122题—买卖股票的最佳时机II</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: prices = [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">3</span> 天（股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span><span class="number">-1</span> = <span class="number">4</span> 。</span><br><span class="line">     随后，在第 <span class="number">4</span> 天（股票价格 = <span class="number">3</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">6</span><span class="number">-3</span> = <span class="number">3</span> 。</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: prices = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 在第 <span class="number">1</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天 （股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span><span class="number">-1</span> = <span class="number">4</span> 。</span><br><span class="line">     注意你不能在第 <span class="number">1</span> 天和第 <span class="number">2</span> 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">输入: prices = [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= prices.length &lt;= <span class="number">3</span> * <span class="number">104</span></span><br><span class="line"><span class="number">0</span> &lt;= prices[i] &lt;= <span class="number">104</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        使用贪心的方法，考虑有盈利就卖的思想</span></span><br><span class="line"><span class="string">        [7, 1, 5, 6] 第二天买入，第四天卖出，收益最大（6-1），所以一般人可能会想，怎么判断不是第三天就卖出了呢? 这里就把问题复杂化了，根据题目的意思，当天卖出以后，当天还可以买入，所以其实可以第三天卖出，第三天买入，第四天又卖出（（5-1）+ （6-5） === 6 - 1）。</span></span><br><span class="line"><span class="string">        所以算法可以直接简化为只要今天比昨天大，就卖出。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            temp  = prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> temp &gt; <span class="number">0</span>:</span><br><span class="line">                res += temp</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode第122题—买卖股票的最佳时机II&quot;&gt;&lt;a href=&quot;#LeetCode第122题—买卖股票的最佳时机II&quot; class=&quot;headerlink&quot; title=&quot;LeetCode第122题—买卖股票的最佳时机II&quot;&gt;&lt;/a&gt;LeetCode第12
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>向量点乘和叉乘</title>
    <link href="www.strivezs.com/2021/05/29/%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98%E5%92%8C%E5%8F%89%E4%B9%98/"/>
    <id>www.strivezs.com/2021/05/29/%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98%E5%92%8C%E5%8F%89%E4%B9%98/</id>
    <published>2021-05-29T12:46:38.214Z</published>
    <updated>2021-05-29T12:46:38.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="向量点乘和叉乘"><a href="#向量点乘和叉乘" class="headerlink" title="向量点乘和叉乘"></a>向量点乘和叉乘</h1><p>假设存在向量a和向量b:<script type="math/tex">a=[a_{1},a_{2},a_{3}],b=[b_{1},b_{2},b_{3}]</script></p><h2 id="点乘"><a href="#点乘" class="headerlink" title="点乘"></a>点乘</h2><p>向量a和向量b的点乘公式如下:</p><script type="math/tex; mode=display">a\bullet b=a_{1}b_{1}+a_{2}b_{2}+a_{3}b_{3}</script><p>要求是向量a和向量的b的维度要相同。</p><h3 id="点乘的几何意义"><a href="#点乘的几何意义" class="headerlink" title="点乘的几何意义"></a>点乘的几何意义</h3><p>点乘的几何意义是可以用来表征或者计算两个向量之间的夹角，以及在b向量或在a向量方向上的投影，公式如下:</p><script type="math/tex; mode=display">a\bullet b=a_{1}b_{1}+a_{2}b_{2}+a_{3}b_{3}=|a||b|cos \theta</script><p>首先假设一下向量构成:</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/itRaNO.png" alt="figure.1"></p><p><strong>推导过程如下</strong>:</p><ul><li>根据上图可以得到c=a-b</li><li>根据三角余弦定理可以得到: <script type="math/tex">c^{2}=a^{2}+b^{2}-2|a||b|cos \theta</script></li><li>根据c=a-b，我们可以对上式变换得到 <script type="math/tex">(a-b) \bullet(a-b)=a^{2}+b^{2}-2 a \bullet b=a^{2}+b^{2}-2|a \| b| \cos \theta</script></li><li>化简上式我们可以得到: <script type="math/tex">a\bullet b=|a||b|cos \theta</script></li><li>因此在已知向量a和向量b长度的情况下，我们可以计算得到a和b的夹角θ</li><li><script type="math/tex; mode=display">\theta=arc\: cos\left ( \frac{a \bullet b}{|a||b|} \right )</script></li></ul><p>根据上述公式就可以计算向量a和向量b之间的夹角，从而就进一步判断出这两个向量是否是同一方向，是否正交，具体对应关系如下:</p><ul><li>a·b&gt;0 : 方向基本相同，夹角在0到90度之间</li><li>a·b=0 : 两个向量正交，相互垂直</li><li>a·b&lt;0 : 方向基本相反，夹角在90度到180度之间</li></ul><h2 id="叉乘"><a href="#叉乘" class="headerlink" title="叉乘"></a>叉乘</h2><p>两个向量的叉乘，又叫向量积、叉积，叉乘的运算结果是一个向量而不是一个标量。并且<strong>两个向量的叉乘与这两个向量组成的坐标平面垂直</strong><br>同样是使用之前假设的向量a和向量b，我们可以得到向量a和向量b的叉乘公式:</p><script type="math/tex; mode=display">a \times b=\left|\begin{array}{lll}\mathrm{i} & \mathrm{j} & \mathrm{k} \\a_{1} & a_{2} & a_{3} \\b_{1} & b_{2} & b_{3}\end{array}\right|=\left(a_{2}b_{3}-a_{3}b_{2}\right) i-\left(a_{1}b_{3}-a_{3}b_{1}\right) j+\left(a_{1}b_{2}-a_{2}b_{1}\right) k</script><p>其中<script type="math/tex">i=(1,0,0),j=(0,1,0),k=(0,0,1)</script>, 其中ijk均为单位向量，最后叉乘的结果为一个向量，所以ijk要为向量，因此单纯的ab相乘再相减得到的标量。<br>因此根据上述i、j、k间的关系，有如下式子(直接用向量表示):</p><script type="math/tex; mode=display">a\times b=\left( a_{2}b_{3}-a_{3}b_{2}, a_{1}b_{3}-a_{3}b_{1}, a_{1}b_{2}-a_{2}b_{1}  \right)</script><p><strong>注意</strong>: 一个向量叉乘自己得到的是0向量，根据右手定则，叉乘得到的结果无论怎么旋转都会永远会垂直这个向量，因此只有0向量满足。</p><h3 id="叉乘的几何意义"><a href="#叉乘的几何意义" class="headerlink" title="叉乘的几何意义"></a>叉乘的几何意义</h3><p>在三维几何中，向量a和向量b的叉乘结果是一个向量，这个向量又称为法向量，它是a和b构成的平面的法向量(垂直)。</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/TRPkZC.png" alt="figure.2"></p><p>如上图。</p><p><strong>右手法则</strong>：使用右手法则来判断a×b向量的方向,如下图所示</p><p><img src="https://gitee.com/zyp521/upload_image/raw/master/ttwC2c.png" alt="figuer.3"></p><p>判断方法如下:</p><ul><li>右手手掌张开，四指并拢，大拇指垂直于四指指向的方向</li><li>伸出右手，四指弯曲，四指与A旋转到B方向一致，那么大拇指指向为C向量的方向</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;向量点乘和叉乘&quot;&gt;&lt;a href=&quot;#向量点乘和叉乘&quot; class=&quot;headerlink&quot; title=&quot;向量点乘和叉乘&quot;&gt;&lt;/a&gt;向量点乘和叉乘&lt;/h1&gt;&lt;p&gt;假设存在向量a和向量b:&lt;script type=&quot;math/tex&quot;&gt;a=[a_{1},a_{2}
      
    
    </summary>
    
    
      <category term="Math" scheme="www.strivezs.com/categories/Math/"/>
    
    
      <category term="Knowledge" scheme="www.strivezs.com/tags/Knowledge/"/>
    
      <category term="Math" scheme="www.strivezs.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.121</title>
    <link href="www.strivezs.com/2021/05/28/LeetCode%E7%AC%AC121%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/28/LeetCode%E7%AC%AC121%E9%A2%98/</id>
    <published>2021-05-28T13:14:32.685Z</published>
    <updated>2021-05-28T13:14:32.685Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第121题—买卖股票的最佳时机</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出，最大利润 = <span class="number">6</span><span class="number">-1</span> = <span class="number">5</span> 。</span><br><span class="line">     注意利润不能是 <span class="number">7</span><span class="number">-1</span> = <span class="number">6</span>, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：prices = [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= prices.length &lt;= <span class="number">105</span></span><br><span class="line"><span class="number">0</span> &lt;= prices[i] &lt;= <span class="number">104</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想:</span></span><br><span class="line"><span class="string">            采用动态规划的方法</span></span><br><span class="line"><span class="string">            时间复杂度为O(n)</span></span><br><span class="line"><span class="string">            记录在i之前的最大利润，并和当前利润比较</span></span><br><span class="line"><span class="string">            记录i天之前的最小值</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(prices) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span>] * len(prices)</span><br><span class="line">        min_value = prices[<span class="number">0</span>]</span><br><span class="line">        max_value = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            max_value = max(max_value, prices[i] - min_value) <span class="comment"># 记录最大利润</span></span><br><span class="line">            min_value = min(min_value,prices[i]) <span class="comment"># 记录第i天之前的最小值</span></span><br><span class="line">        <span class="keyword">return</span> max_value</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.maxProfit([<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第121题—买卖股票的最佳时机&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.120</title>
    <link href="www.strivezs.com/2021/05/27/LeetCode%E7%AC%AC120%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/27/LeetCode%E7%AC%AC120%E9%A2%98/</id>
    <published>2021-05-27T15:39:01.452Z</published>
    <updated>2021-05-27T15:39:01.452Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第120题—三角形最小路径和</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p><p>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</p><p>示例 1：</p><p>输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]<br>输出：11<br>解释：如下面简图所示：<br>2<br>3 4<br>6 5 7<br>4 1 8 3<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。<br>示例 2：</p><p>输入：triangle = [[-10]]<br>输出：-10</p><p>提示：</p><p>1 &lt;= triangle.length &lt;= 200<br>triangle[0].length == 1<br>triangle[i].length == triangle[i - 1].length + 1<br>-104 &lt;= triangle[i][j] &lt;= 104</p><p>进阶：</p><p>你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题吗？</p><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    maxSum = sys.maxsize <span class="comment"># 设置足底啊之</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">limit_dfs</span><span class="params">(self,triangle,j,iList,curSum,curDepth,depth)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param triangle: List[List[Int]] 所有数值</span></span><br><span class="line"><span class="string">        :param j: Int 上一个节点的纵坐标</span></span><br><span class="line"><span class="string">        :param iList: List[Int] 当前节点所在的层</span></span><br><span class="line"><span class="string">        :param curParam: Int 当前层之前的路径和</span></span><br><span class="line"><span class="string">        :param curDepth: Int 当前深度</span></span><br><span class="line"><span class="string">        :param depth: 最大深度</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        t = iList[j]</span><br><span class="line">        curSum += iList[j]</span><br><span class="line">        <span class="keyword">if</span> depth == curDepth:</span><br><span class="line">            <span class="keyword">if</span> curSum &lt; self.maxSum:</span><br><span class="line">                self.maxSum = curSum</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.limit_dfs(triangle, j, triangle[curDepth+<span class="number">1</span>], curSum, curDepth+<span class="number">1</span>, depth)</span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span> &lt; len(triangle[curDepth+<span class="number">1</span>]):</span><br><span class="line">            self.limit_dfs(triangle, j+<span class="number">1</span>, triangle[curDepth + <span class="number">1</span>], curSum, curDepth+<span class="number">1</span>, depth)</span><br><span class="line">    <span class="comment"># 超时版本</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        核心思想:</span></span><br><span class="line"><span class="string">            每个节点，只能访问它的[i+1][j]/[i+1][j+1] 两个节点</span></span><br><span class="line"><span class="string">            考虑采用递归来判断, 有点类似限制二叉树的访问方法</span></span><br><span class="line"><span class="string">        :type triangle: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int 返回最大值</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.limit_dfs(triangle,<span class="number">0</span>,triangle[<span class="number">0</span>],<span class="number">0</span>,<span class="number">0</span>,len(triangle)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.maxSum</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 参考大佬的版本</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_version</span><span class="params">(self,triangle)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(triangle) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                triangle[i - <span class="number">1</span>][j] += min(triangle[i][j], triangle[i][j + <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.minimumTotal([[<span class="number">-1</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-3</span>]]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第120题—三角形最小路径和&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.119</title>
    <link href="www.strivezs.com/2021/05/26/LeetCode%E7%AC%AC119%E9%A2%98/"/>
    <id>www.strivezs.com/2021/05/26/LeetCode%E7%AC%AC119%E9%A2%98/</id>
    <published>2021-05-26T14:10:06.243Z</published>
    <updated>2021-05-26T14:10:06.243Z</updated>
    
    <content type="html"><![CDATA[<h1>LeetCode第119题—杨辉三角II</h1><p>自己代码的开源仓库:<a href="https://github.com/zs670980918/LeetCode_Coding_Record">click here</a>  欢迎Star和Fork :)</p><h2 id="题目描述"><a class="header-anchor" href="#题目描述">¶</a>题目描述</h2><p>给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="fiogure.1"></p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">3</span></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    res = []  <span class="comment"># 全局结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># fixme: 递归分治生成数组</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">genrate_iList</span><span class="params">(self, pre_list, depth, goal_depth)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        采用递归分治的方法来生成每一层的数组</span></span><br><span class="line"><span class="string">        :param pre_list: List 上一层生成的数组</span></span><br><span class="line"><span class="string">        :param depth: Int 当前深度</span></span><br><span class="line"><span class="string">        :param goal_depth: Int 目标深度</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> depth == goal_depth + <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        temp = []</span><br><span class="line">        temp.append(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(pre_list) - <span class="number">1</span>):</span><br><span class="line">            temp.append(pre_list[i] + pre_list[i + <span class="number">1</span>])</span><br><span class="line">        temp.append(<span class="number">1</span>)</span><br><span class="line">        self.res.append(temp)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归调用</span></span><br><span class="line">        self.genrate_iList(temp, depth + <span class="number">1</span>, goal_depth)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRow</span><span class="params">(self, numRows)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type numRows: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">            由于每个值都是它上面两个值的加和，因此考虑为分治问题</span></span><br><span class="line"><span class="string">            考虑还是使用递归的方法，因此每次传入的数组就是上一次递归生成的数组.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.res = []</span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.res</span><br><span class="line">        self.res.append([<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.res</span><br><span class="line">        self.res.append([<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> self.res</span><br><span class="line">        self.genrate_iList([<span class="number">1</span>, <span class="number">1</span>], <span class="number">3</span>, numRows+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;LeetCode第119题—杨辉三角II&lt;/h1&gt;
&lt;p&gt;自己代码的开源仓库:&lt;a href=&quot;https://github.com/zs670980918/LeetCode_Coding_Record&quot;&gt;click here&lt;/a&gt;  欢迎Star和Fork :)&lt;/p
      
    
    </summary>
    
    
      <category term="OJ" scheme="www.strivezs.com/categories/OJ/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/categories/OJ/LeetCode/"/>
    
    
      <category term="Programing" scheme="www.strivezs.com/tags/Programing/"/>
    
      <category term="LeetCode" scheme="www.strivezs.com/tags/LeetCode/"/>
    
      <category term="OJ" scheme="www.strivezs.com/tags/OJ/"/>
    
  </entry>
  
</feed>
